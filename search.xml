<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【OpenCV入门】形状/轮廓的检测</title>
      <link href="/2021/10/12/%E3%80%90OpenCV%E5%85%A5%E9%97%A8%E3%80%91%E5%BD%A2%E7%8A%B6-%E8%BD%AE%E5%BB%93%E7%9A%84%E6%A3%80%E6%B5%8B/"/>
      <url>/2021/10/12/%E3%80%90OpenCV%E5%85%A5%E9%97%A8%E3%80%91%E5%BD%A2%E7%8A%B6-%E8%BD%AE%E5%BB%93%E7%9A%84%E6%A3%80%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<hr><p>我的个人博客：<a href="https://oceanbloom.github.io/">谋仁·Blog</a><br>微信公众号：谋仁的麻袋<br>CSDN：曹谋仁</p><hr><h1 id="检测前预处理—-边缘检测二值图"><a href="#检测前预处理—-边缘检测二值图" class="headerlink" title="检测前预处理—-边缘检测二值图"></a>检测前预处理—-边缘检测二值图</h1><p>所谓形状/轮廓的检测就是把待检测图像中的边缘轮廓组成的图形识别出来，并检测出轮廓点，再对其进行判断。所以为便于检测轮廓，我们要在检测之前进行一些预处理：<br>灰度-&gt;高斯滤波-&gt;Canny边缘检测算法-&gt;图像膨胀<br>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// 形状检测前的预处理（灰度-&gt;高斯滤波-&gt;Canny边缘算法-&gt;膨胀）</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;imgIn&quot;&gt;Mat 类，输入图像&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Mat类，预处理后的图像&lt;/returns&gt;</span></span><br><span class="line"><span class="function">Mat <span class="title">preProcessing</span><span class="params">(Mat imgIn)</span> </span>&#123;</span><br><span class="line">Mat imgGray, imgBlur, imgCanny, imgDila;</span><br><span class="line"><span class="comment">//先定义一个内核</span></span><br><span class="line">Mat kernel = <span class="built_in">getStructuringElement</span>(MORPH_RECT, <span class="built_in">Size</span>(<span class="number">3</span>, <span class="number">3</span>));</span><br><span class="line"><span class="built_in">cvtColor</span>(imgIn, imgGray, COLOR_BGR2GRAY, <span class="number">0</span>);<span class="comment">//灰度变换</span></span><br><span class="line"><span class="built_in">GaussianBlur</span>(imgGray, imgBlur, <span class="built_in">Size</span>(<span class="number">65</span>, <span class="number">65</span>), <span class="number">1</span>, <span class="number">1</span>);<span class="comment">//高斯滤波去噪点</span></span><br><span class="line"><span class="built_in">Canny</span>(imgBlur, imgCanny, <span class="number">40</span>, <span class="number">120</span>);<span class="comment">//Canny边缘检测</span></span><br><span class="line"><span class="built_in">dilate</span>(imgCanny, imgDila, kernel);<span class="comment">//图像膨胀</span></span><br><span class="line"><span class="keyword">return</span> imgDila;<span class="comment">//返回处理完后的图像</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="findContours函数—-检测轮廓"><a href="#findContours函数—-检测轮廓" class="headerlink" title="findContours函数—-检测轮廓"></a>findContours函数—-检测轮廓</h1><p>函数作用：从二值图像中检测轮廓<br>函数的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findContours</span><span class="params">( </span></span></span><br><span class="line"><span class="params"><span class="function">InputArray image, </span></span></span><br><span class="line"><span class="params"><span class="function">OutputArrayOfArrays contours,</span></span></span><br><span class="line"><span class="params"><span class="function">    OutputArray hierarchy, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> mode,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> method, </span></span></span><br><span class="line"><span class="params"><span class="function">    Point offset = Point()</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br></pre></td></tr></table></figure><p>参数解释：</p><ul><li>image：8位单通道图像，非零像素视为1，零像素视为0。这里一般输入经过Canny边缘检测、inRange选择、拉普拉斯等变换成01图像。</li><li>contours：检测到轮廓的变量，每一个轮廓被存储为点向量。定义轮廓的类型为：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;Point&gt;&gt;</span><br></pre></td></tr></table></figure><p>这是一个双重向量，外层向量存放待检测图中所有形状的轮廓；内层向量存放的是某一个轮廓的点集合（一组由连续的Point构成的点的集合的向量）</p><ul><li>hierarchy：参数定义的类型为：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;Vec4i&gt; hierarchy</span><br></pre></td></tr></table></figure><p>Vec4i的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Vec&lt;<span class="keyword">int</span>, <span class="number">4</span>&gt; Vec4i</span><br></pre></td></tr></table></figure><p>向量内每个元素都包含了4个int型变量，所以从定义上看，hierarchy是一个向量，向量内每个元素都是一个包含4个int型的数组。<br>向量hierarchy内的元素和轮廓向量contours内的元素是一一对应的，向量的容量相同。hierarchy内每个元素的4个int型变量是hierarchy[i][0] ~ hierarchy[i][3]，分别表示当前轮廓 i 的后一个轮廓、前一个轮廓、父轮廓和内嵌轮廓的编号索引。如果当前轮廓没有对应的四者中的其一的话，则相应的hierarchy[i][*]被置为-1。</p><ul><li>mode：轮廓的检测模式，其取值定义如下：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">RetrievalModes</span> &#123;</span></span><br><span class="line">    <span class="comment">/** retrieves only the extreme outer contours. It sets `hierarchy[i][2]=hierarchy[i][3]=-1` for</span></span><br><span class="line"><span class="comment">    all the contours. */</span></span><br><span class="line">    RETR_EXTERNAL  = <span class="number">0</span>,</span><br><span class="line">    <span class="comment">/** retrieves all of the contours without establishing any hierarchical relationships. */</span></span><br><span class="line">    RETR_LIST      = <span class="number">1</span>,</span><br><span class="line">    <span class="comment">/** retrieves all of the contours and organizes them into a two-level hierarchy. At the top</span></span><br><span class="line"><span class="comment">    level, there are external boundaries of the components. At the second level, there are</span></span><br><span class="line"><span class="comment">    boundaries of the holes. If there is another contour inside a hole of a connected component, it</span></span><br><span class="line"><span class="comment">    is still put at the top level. */</span></span><br><span class="line">    RETR_CCOMP     = <span class="number">2</span>,</span><br><span class="line">    <span class="comment">/** retrieves all of the contours and reconstructs a full hierarchy of nested contours.*/</span></span><br><span class="line">    RETR_TREE      = <span class="number">3</span>,</span><br><span class="line">    RETR_FLOODFILL = <span class="number">4</span> <span class="comment">//!&lt;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>翻译如下：<br>    RETR_EXTERNAL：只检测最外围轮廓，包含在外围轮廓内的内围轮廓被忽略；<br>    RETR_LIST：检测所有的轮廓，包括内围、外围轮廓，但是检测到的轮廓不建立等级关系，彼此之间独立，没有等级关系。这就意味着这个检索模式下不存在父轮廓或内嵌轮廓，所以hierarchy向量内所有元素的第3、第4个分量都会被置为-1；<br>    RETR_CCOMP：检测所有的轮廓，但所有轮廓只建立两个等级关系，外围为顶层，若外围内的内围轮廓还包含了其他的轮廓信息，则内围内的所有轮廓均归属于顶层；<br>    RETR_TREE：检测所有轮廓，所有轮廓建立一个等级树结构。外层轮廓包含内层轮廓，内层轮廓还可以继续包含内嵌轮廓。<br>    RETR_FLOODFILL：官方没有介绍，暂时不知道</p><blockquote><p>参考：<a href="https://www.cnblogs.com/GaloisY/p/11062065.html">https://www.cnblogs.com/GaloisY/p/11062065.html</a></p></blockquote><ul><li>method：轮廓逼近方法，取值定义如下：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ContourApproximationModes</span> &#123;</span></span><br><span class="line">    <span class="comment">/** stores absolutely all the contour points. That is, any 2 subsequent points (x1,y1) and</span></span><br><span class="line"><span class="comment">    (x2,y2) of the contour will be either horizontal, vertical or diagonal neighbors, that is,</span></span><br><span class="line"><span class="comment">    max(abs(x1-x2),abs(y2-y1))==1. */</span></span><br><span class="line">    CHAIN_APPROX_NONE      = <span class="number">1</span>,</span><br><span class="line">    <span class="comment">/** compresses horizontal, vertical, and diagonal segments and leaves only their end points.</span></span><br><span class="line"><span class="comment">    For example, an up-right rectangular contour is encoded with 4 points. */</span></span><br><span class="line">    CHAIN_APPROX_SIMPLE    = <span class="number">2</span>,</span><br><span class="line">    <span class="comment">/** applies one of the flavors of the Teh-Chin chain approximation algorithm @cite TehChin89 */</span></span><br><span class="line">    CHAIN_APPROX_TC89_L1   = <span class="number">3</span>,</span><br><span class="line">    <span class="comment">/** applies one of the flavors of the Teh-Chin chain approximation algorithm @cite TehChin89 */</span></span><br><span class="line">    CHAIN_APPROX_TC89_KCOS = <span class="number">4</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>翻译如下：<br>    CHAIN_APPROX_NONE：获取每个轮廓的每个像素，相邻的两个点的像素位置差不超过1；<br>    CHAIN_APPROX_SIMPLE：压缩水平方向，垂直方向，对角线方向的元素，值保留该方向的重点坐标，如果一个矩形轮廓只需4个点来保存轮廓信息；<br>    CHAIN_APPROX_TC89_L1和CHAIN_APPROX_TC89_KCOS：使用Teh-Chinl链逼近算法中的一种</p><blockquote><p>参考：<a href="https://blog.csdn.net/qq_42887760/article/details/86565601">https://blog.csdn.net/qq_42887760/article/details/86565601</a></p></blockquote><ul><li>offset：轮廓相对于原始图像的偏移量。例如：如果这里写Size(-10,-20)，最终绘制的轮廓相对原图实际轮廓的位置往左偏移了10个像素，往上偏移了20个像素。如果是Size(10,20)，就代表往右偏移10个像素，往下偏移20个像素。</li></ul><p>findContours函数另一个重载与该定义唯一的区别是少了hierarchy参数，其他参数及含义都一样，故在此不多赘述。</p><h1 id="contourArea、arcLength函数—-面积、周长"><a href="#contourArea、arcLength函数—-面积、周长" class="headerlink" title="contourArea、arcLength函数—-面积、周长"></a>contourArea、arcLength函数—-面积、周长</h1><h2 id="contourArea函数—-轮廓面积"><a href="#contourArea函数—-轮廓面积" class="headerlink" title="contourArea函数—-轮廓面积"></a>contourArea函数—-轮廓面积</h2><p>函数作用：计算图像轮廓的面积<br>函数的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">contourArea</span><span class="params">( InputArray contour, <span class="keyword">bool</span> oriented = <span class="literal">false</span> )</span></span>;</span><br></pre></td></tr></table></figure><p>参数解释：</p><ul><li>contour：输入轮廓的点集合</li><li>oriented：表示某一个方向上轮廓的的面积值，顺时针或者逆时针，一般选择默认false</li></ul><h2 id="arcLength函数—-轮廓长度"><a href="#arcLength函数—-轮廓长度" class="headerlink" title="arcLength函数—-轮廓长度"></a>arcLength函数—-轮廓长度</h2><p>函数作用：计算图像轮廓的周长<br>函数的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">arcLength</span><span class="params">( InputArray curve, <span class="keyword">bool</span> closed )</span></span>;</span><br></pre></td></tr></table></figure><p>参数解释：</p><ul><li>curve：输入轮廓的点集合</li><li>closed：表示曲线是否封闭</li></ul><h1 id="approxPolyDP函数—-曲线折线化"><a href="#approxPolyDP函数—-曲线折线化" class="headerlink" title="approxPolyDP函数—-曲线折线化"></a>approxPolyDP函数—-曲线折线化</h1><p>函数作用：将曲线或多边形用更少顶点的折现来拟合，即把一个连续光滑曲线折线化<br>曲线折线化的目的是获得折线顶点个数，进而可以判断出该轮廓大概是什么形状<br>函数的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">approxPolyDP</span><span class="params">( </span></span></span><br><span class="line"><span class="params"><span class="function">InputArray curve,</span></span></span><br><span class="line"><span class="params"><span class="function">    OutputArray approxCurve,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">double</span> epsilon, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">bool</span> closed </span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br></pre></td></tr></table></figure><p>参数解释：</p><ul><li>curve：Mat类或vector类，2D点集，一般由轮廓线点组成的点集</li><li>approxCurve：输出的折线化后点集</li><li>epsilon：指定的精度，也即是原始曲线与近似曲线之间的最大距离</li><li>closed：若为true，则说明拟合曲线是闭合的；反之，若为false，则不为闭合曲线<h1 id="drawContours函数—-绘制轮廓"><a href="#drawContours函数—-绘制轮廓" class="headerlink" title="drawContours函数—-绘制轮廓"></a>drawContours函数—-绘制轮廓</h1>函数作用：绘制已经找到的图像的轮廓<br>函数的定义：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">drawContours</span><span class="params">( </span></span></span><br><span class="line"><span class="params"><span class="function">InputOutputArray image, </span></span></span><br><span class="line"><span class="params"><span class="function">InputArrayOfArrays contours,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> contourIdx, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> Scalar&amp; color,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> thickness = <span class="number">1</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> lineType = LINE_8,</span></span></span><br><span class="line"><span class="params"><span class="function">    InputArray hierarchy = noArray(),</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> maxLevel = INT_MAX, </span></span></span><br><span class="line"><span class="params"><span class="function">    Point offset = Point() </span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br></pre></td></tr></table></figure><p>参数解释：</p><ul><li>image：要绘制轮廓的图像</li><li>contours：轮廓线的点集合</li><li>contourIdx：指定要绘制轮廓的编号，如果是负数，则绘制所有的轮廓</li><li>color：轮廓线的颜色，通常用Scalar(blue, green, red)调色</li><li>thickness：轮廓线的宽度，如果是-1（cv2.FILLED），则为填充模式</li><li>lineType：线型，取值的定义：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">LineTypes</span> &#123;</span></span><br><span class="line">    FILLED  = <span class="number">-1</span>,</span><br><span class="line">    LINE_4  = <span class="number">4</span>, <span class="comment">//!&lt; 4-connected line--4连通线型</span></span><br><span class="line">    LINE_8  = <span class="number">8</span>, <span class="comment">//!&lt; 8-connected line--8连通线型</span></span><br><span class="line">    LINE_AA = <span class="number">16</span> <span class="comment">//!&lt; antialiased line--抗锯齿线型</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>hierarchy：关于层级的可选参数，只有绘制部分轮廓时才会用到</li><li>maxLevel：绘制轮廓的最高级别，这个参数只有hierarchy有效的时候才有效<br> maxLevel=0—–绘制与输入轮廓属于同一等级的所有轮廓即输入轮廓和与其相邻的轮廓<br> maxLevel=1—–绘制与输入轮廓同一等级的所有轮廓与其子节点<br> maxLevel=2—–绘制与输入轮廓同一等级的所有轮廓与其子节点以及子节点的子节点</li><li>offset：绘制的轮廓相对于已找到的轮廓位置的偏移量。例如：如果这里写Size(-10,-20)，最终绘制的轮廓相对已找到轮廓的位置往左偏移了10个像素，往上偏移了20个像素。如果是Size(10,20)，就代表往右偏移10个像素，往下偏移20个像素。<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1>源代码：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;opencv_world453d.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;opencv_world453.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// _DEBUG</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// 对预处理后的图像检测轮廓并标出已定义的简单形状</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;imgDil&quot;&gt;与处理后的图像&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;img&quot;&gt;待检测轮廓的原图&lt;/param&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetContour</span><span class="params">(Mat imgDil, Mat img)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;vector&lt;Point&gt;&gt; contour;</span><br><span class="line">vector&lt;Vec4i&gt; hierarchy;</span><br><span class="line"><span class="built_in">findContours</span>(imgDil, contour, hierarchy, RETR_EXTERNAL, CHAIN_APPROX_NONE);</span><br><span class="line">vector&lt;vector&lt;Point&gt;&gt; <span class="built_in">conPoly</span>(contour.<span class="built_in">size</span>());<span class="comment">//定义用于存放轮廓折线化后的变量</span></span><br><span class="line"><span class="function">vector&lt;Rect&gt; <span class="title">boundRect</span><span class="params">(contour.size())</span></span>;</span><br><span class="line"><span class="comment">//contour.size()是在该图像中检测到的轮廓个数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; contour.<span class="built_in">size</span>(); i++)<span class="comment">//所有轮廓遍历</span></span><br><span class="line">&#123;</span><br><span class="line">string objectType;<span class="comment">//形状名称</span></span><br><span class="line"><span class="keyword">float</span> peri = <span class="built_in">arcLength</span>(contour[i], <span class="literal">true</span>);<span class="comment">//轮廓周长</span></span><br><span class="line"><span class="comment">//0.015* peri表示拟合的精度</span></span><br><span class="line"><span class="built_in">approxPolyDP</span>(contour[i], conPoly[i], <span class="number">0.015</span> * peri, <span class="literal">true</span>);<span class="comment">//把一个连续光滑曲线折线化</span></span><br><span class="line">boundRect[i] = <span class="built_in">boundingRect</span>(conPoly[i]);<span class="comment">//获得包覆该轮廓最小矩形</span></span><br><span class="line"><span class="keyword">int</span> objCor = (<span class="keyword">int</span>)conPoly[i].<span class="built_in">size</span>();<span class="comment">//获取折线化后轮廓的顶点个数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> region 定义形状</span></span><br><span class="line"><span class="keyword">if</span> (objCor == <span class="number">3</span>) <span class="comment">//三角形</span></span><br><span class="line">objectType = <span class="string">&quot;Tri&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (objCor == <span class="number">4</span>) &#123;<span class="comment">//矩形</span></span><br><span class="line"><span class="keyword">float</span> aspRatio = (<span class="keyword">float</span>)boundRect[i].width / boundRect[i].height;<span class="comment">//长宽比来区别正方形与矩形</span></span><br><span class="line"><span class="keyword">if</span> (aspRatio &gt; <span class="number">0.95</span> &amp;&amp; aspRatio &lt; <span class="number">1.05</span>) </span><br><span class="line">objectType = <span class="string">&quot;Square&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">objectType = <span class="string">&quot;Rect&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (objCor &gt; <span class="number">4</span>) <span class="comment">//圆形</span></span><br><span class="line">objectType = <span class="string">&quot;Circle&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> endregion</span></span><br><span class="line"><span class="built_in">drawContours</span>(img, conPoly, i, <span class="built_in">Scalar</span>(<span class="number">187</span>, <span class="number">109</span>, <span class="number">68</span>), <span class="number">3</span>, LINE_AA);<span class="comment">//画出轮廓线</span></span><br><span class="line"><span class="built_in">rectangle</span>(img, boundRect[i].<span class="built_in">tl</span>(), boundRect[i].<span class="built_in">br</span>(), <span class="built_in">Scalar</span>(<span class="number">72</span>,<span class="number">255</span>,<span class="number">104</span>), <span class="number">4</span>);<span class="comment">//用矩形框住选出的图形</span></span><br><span class="line"><span class="comment">//标出已定义出的图形名称</span></span><br><span class="line"><span class="built_in">putText</span>(img, objectType, &#123; boundRect[i].x,boundRect[i].y - <span class="number">5</span> &#125; , <span class="number">1</span>, FONT_HERSHEY_PLAIN, <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">69</span>, <span class="number">255</span>), <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// 形状检测前的预处理（灰度-&gt;高斯滤波-&gt;Canny边缘算法-&gt;膨胀）</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;imgIn&quot;&gt;Mat 类，输入图像&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Mat类，预处理后的图像&lt;/returns&gt;</span></span><br><span class="line"><span class="function">Mat <span class="title">PreProcessing</span><span class="params">(Mat imgIn)</span> </span>&#123;</span><br><span class="line">Mat imgGray, imgBlur, imgCanny, imgDila;</span><br><span class="line"><span class="comment">//先定义一个内核</span></span><br><span class="line">Mat kernel = <span class="built_in">getStructuringElement</span>(MORPH_RECT, <span class="built_in">Size</span>(<span class="number">3</span>, <span class="number">3</span>));</span><br><span class="line"><span class="built_in">cvtColor</span>(imgIn, imgGray, COLOR_BGR2GRAY, <span class="number">0</span>);<span class="comment">//灰度变换</span></span><br><span class="line"><span class="built_in">GaussianBlur</span>(imgGray, imgBlur, <span class="built_in">Size</span>(<span class="number">65</span>, <span class="number">65</span>), <span class="number">1</span>, <span class="number">1</span>);<span class="comment">//高斯滤波去噪点</span></span><br><span class="line"><span class="built_in">Canny</span>(imgBlur, imgCanny, <span class="number">40</span>, <span class="number">120</span>);<span class="comment">//Canny边缘检测</span></span><br><span class="line"><span class="built_in">dilate</span>(imgCanny, imgDila, kernel);<span class="comment">//图像膨胀</span></span><br><span class="line"><span class="keyword">return</span> imgDila;<span class="comment">//返回处理完后的图像</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">string path = <span class="string">&quot;D:\\My Bags\\图片\\shapes.png&quot;</span>;<span class="comment">//原图路径</span></span><br><span class="line">Mat img = <span class="built_in">imread</span>(path);<span class="comment">//读取图片</span></span><br><span class="line">Mat imgProcessed = <span class="built_in">PreProcessing</span>(img);<span class="comment">//图像预处理</span></span><br><span class="line"><span class="built_in">GetContour</span>(imgProcessed , img);<span class="comment">//检测轮廓并标出简单图形名称</span></span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, img);<span class="comment">//显示出来</span></span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="https://img-blog.csdnimg.cn/4d37e853686d4e7b8890aac81c83943e.png#pic_center"></p>]]></content>
      
      
      <categories>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【OpenCV入门】颜色检测/滑块的创建</title>
      <link href="/2021/10/09/%E3%80%90OpenCV%E5%85%A5%E9%97%A8%E3%80%91%E9%A2%9C%E8%89%B2%E6%A3%80%E6%B5%8B-%E6%BB%91%E5%9D%97%E7%9A%84%E5%88%9B%E5%BB%BA/"/>
      <url>/2021/10/09/%E3%80%90OpenCV%E5%85%A5%E9%97%A8%E3%80%91%E9%A2%9C%E8%89%B2%E6%A3%80%E6%B5%8B-%E6%BB%91%E5%9D%97%E7%9A%84%E5%88%9B%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<hr><p>我的个人博客：<a href="https://oceanbloom.github.io/">谋仁·Blog</a><br>微信公众号：谋仁的麻袋<br>CSDN：曹谋仁</p><hr><h1 id="颜色的检测"><a href="#颜色的检测" class="headerlink" title="颜色的检测"></a>颜色的检测</h1><h2 id="转换HSV模型"><a href="#转换HSV模型" class="headerlink" title="转换HSV模型"></a>转换HSV模型</h2><p>颜色检测通常要从HSV图像中检测，所以先将原图转换成HSV模型。（用cvtColor函数，详情参考本人这篇文章：<a href="https://blog.csdn.net/ZBC010/article/details/120572996?spm=1001.2014.3001.5501">【OpenCV入门】一些基本的图像处理</a>）</p><h2 id="inRange函数"><a href="#inRange函数" class="headerlink" title="inRange函数"></a>inRange函数</h2><p>函数作用：对图像进行二值化处理，将在阈值范围[lowerb,upperb]内的像素值设置为白色（255），而不在阈值区间内的像素值设置为黑色（0）。</p><p>函数定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inRange</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">InputArray src, </span></span></span><br><span class="line"><span class="params"><span class="function">InputArray lowerb,</span></span></span><br><span class="line"><span class="params"><span class="function">    InputArray upperb, </span></span></span><br><span class="line"><span class="params"><span class="function">    OutputArray dst</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br></pre></td></tr></table></figure><p>参数解释：</p><ul><li>src：输入图像</li><li>lowerb：包含下边界的数组或标量</li><li>upperb：包含上边界的数组或标量</li><li>dst：输出尺寸与输入图像相同的二值化图像图像</li></ul><p>为了准确检测到预期颜色，我们要严格选取下限lowerb和上限upperb的H、S、V三个参数的值。所以，为便于寻找准确的阈值，我们通常配合createTrackbar函数生成滑块在运行程序后通过拖动滑块来改变参数，下面我就来介绍一下createTrackbar函数。</p><h1 id="createTrackbar函数—-滑块"><a href="#createTrackbar函数—-滑块" class="headerlink" title="createTrackbar函数—-滑块"></a>createTrackbar函数—-滑块</h1><p>函数作用：创建滑块，在运行程序后通过拖动滑块来改变某些参数。</p><p>函数定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">createTrackbar</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">const</span> String&amp; trackbarname, </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">const</span> String&amp; winname,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span>* value, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> count,</span></span></span><br><span class="line"><span class="params"><span class="function">    TrackbarCallback onChange = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">void</span>* userdata = <span class="number">0</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br></pre></td></tr></table></figure><p>参数解释：</p><ul><li>trackbarname：滑块的名字</li><li>winname：滑块所在窗口的名字</li><li>value：整形指针，用于存放该滑块改变的变量的地址</li><li>count：value的最大值</li><li>onChange：当想通过拖动滑块来改变某些函数时，这里写自己定义的函数。当拖动滑块时自动调用该回调函数，然后对图像做相应处理。（默认0）TrackbarCallback类的定义：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** @brief Callback function for Trackbar see cv::createTrackbar</span></span><br><span class="line"><span class="comment">@param pos current position of the specified trackbar.</span></span><br><span class="line"><span class="comment">@param userdata The optional parameter.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*TrackbarCallback)</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">void</span>* userdata)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>userdata：用户自定义数据，使用它可以避免使用全局变量<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1>源代码：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;opencv_world453d.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;opencv_world453.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// _DEBUG</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//控制取色区域的参数</span></span><br><span class="line">    <span class="comment">//先大概赋一些值，运行后用滑块改变各个参数选取要提取的颜色</span></span><br><span class="line">    <span class="keyword">int</span> hmin = <span class="number">100</span>, smin = <span class="number">100</span>, vmin = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> hmax = <span class="number">200</span>, smax = <span class="number">200</span>, vmax = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    Mat imgHSV,imgDstColor;</span><br><span class="line">    string path = <span class="string">&quot;D:\\My Bags\\图片\\Test.jpg&quot;</span>;</span><br><span class="line">    Mat imgIn = <span class="built_in">imread</span>(path);</span><br><span class="line">    <span class="built_in">cvtColor</span>(imgIn, imgHSV, COLOR_BGR2HSV);<span class="comment">//转换HSV模型</span></span><br><span class="line">    <span class="comment">//创建一个窗口用于放置调整参数的滑块</span></span><br><span class="line">    <span class="comment">//命名“取色控制台”，WINDOW_NORMAL指可调整窗口大小</span></span><br><span class="line">    <span class="built_in">namedWindow</span>(<span class="string">&quot;取色控制台&quot;</span>, WINDOW_NORMAL);</span><br><span class="line">    <span class="comment">//创建六个控制取色参数的滑块</span></span><br><span class="line">    <span class="built_in">createTrackbar</span>(<span class="string">&quot;色调下限&quot;</span>, <span class="string">&quot;取色控制台&quot;</span>, &amp;hmin, <span class="number">180</span>);</span><br><span class="line">    <span class="built_in">createTrackbar</span>(<span class="string">&quot;色调上限&quot;</span>, <span class="string">&quot;取色控制台&quot;</span>, &amp;hmax, <span class="number">180</span>);</span><br><span class="line">    <span class="built_in">createTrackbar</span>(<span class="string">&quot;饱和度下限&quot;</span>, <span class="string">&quot;取色控制台&quot;</span>, &amp;smin, <span class="number">255</span>);</span><br><span class="line">    <span class="built_in">createTrackbar</span>(<span class="string">&quot;饱和度上限&quot;</span>, <span class="string">&quot;取色控制台&quot;</span>, &amp;smax, <span class="number">255</span>);</span><br><span class="line">    <span class="built_in">createTrackbar</span>(<span class="string">&quot;明度下限&quot;</span>, <span class="string">&quot;取色控制台&quot;</span>, &amp;vmin, <span class="number">255</span>);</span><br><span class="line">    <span class="built_in">createTrackbar</span>(<span class="string">&quot;明度上限&quot;</span>, <span class="string">&quot;取色控制台&quot;</span>, &amp;vmax, <span class="number">255</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">Scalar <span class="title">lower</span><span class="params">(hmin, smin, vmin)</span></span>;<span class="comment">//下限</span></span><br><span class="line">        <span class="function">Scalar <span class="title">upper</span><span class="params">(hmax, smax, vmax)</span></span>;<span class="comment">//上限</span></span><br><span class="line">        <span class="built_in">inRange</span>(imgHSV, lower, upper, imgDstColor);</span><br><span class="line">        <span class="built_in">imshow</span>(<span class="string">&quot;原图&quot;</span>, imgIn);</span><br><span class="line">        <span class="built_in">imshow</span>(<span class="string">&quot;HSV图&quot;</span>, imgHSV);</span><br><span class="line">        <span class="built_in">imshow</span>(<span class="string">&quot;色彩取样图&quot;</span>, imgDstColor);</span><br><span class="line">        <span class="built_in">waitKey</span>(<span class="number">1</span>);<span class="comment">//每隔1ms刷新一次</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="https://img-blog.csdnimg.cn/2bf987ae8a474743a9351eb1fd3fc74d.png#pic_center"></p>]]></content>
      
      
      <categories>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【OpenCV入门】透视变换</title>
      <link href="/2021/10/08/%E3%80%90OpenCV%E5%85%A5%E9%97%A8%E3%80%91%E9%80%8F%E8%A7%86%E5%8F%98%E6%8D%A2/"/>
      <url>/2021/10/08/%E3%80%90OpenCV%E5%85%A5%E9%97%A8%E3%80%91%E9%80%8F%E8%A7%86%E5%8F%98%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<hr><p>我的个人博客：<a href="https://oceanbloom.github.io/">谋仁·Blog</a><br>微信公众号：谋仁的麻袋<br>CSDN：曹谋仁</p><hr><h1 id="Point2f类"><a href="#Point2f类" class="headerlink" title="Point2f类"></a>Point2f类</h1><p>图像由一个个像素点组成，我们为了存储每一个像素点，通常用Point类中(x,y)坐标来表示。Point2f表示Point类的两个数据x,y为float类型。<br>为了将原图中的某一块区域处理成鸟瞰图，我们首先要用Point2f来确定几个点来框定待处理区域。在这里，我们将要将一张斜放的扑克牌处理成鸟瞰图。故用四个点就足够确定其范围。<br>然后再建立一个Point2f类数组存放与原图框定区域对应的处理后的鸟瞰图在新窗口中的位置。相应代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Point2f srcPoint[<span class="number">4</span>] = &#123; &#123;<span class="number">530</span>,<span class="number">143</span>&#125;,&#123;<span class="number">773</span>,<span class="number">193</span>&#125;,&#123;<span class="number">403</span>,<span class="number">394</span>&#125;, &#123;<span class="number">674</span>,<span class="number">455</span>&#125; &#125;;<span class="comment">//原图中框定四个点</span></span><br><span class="line">Point2f dstPoint[<span class="number">4</span>] = &#123; &#123;<span class="number">0.0f</span>,<span class="number">0.0f</span>&#125;,&#123;cardWidth,<span class="number">0.0f</span>&#125;,&#123;<span class="number">0.0f</span>,cardHeight&#125;, &#123;cardWidth,cardHeight&#125; &#125;;<span class="comment">//分别对应鸟瞰图四个点</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="getPerspectiveTransform函数"><a href="#getPerspectiveTransform函数" class="headerlink" title="getPerspectiveTransform函数"></a>getPerspectiveTransform函数</h1><p>函数作用：根据输入和输出点获得图像<strong>透视变换</strong>的矩阵<br>重载一：<br>函数定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Mat <span class="title">getPerspectiveTransform</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">const</span> Point2f src[], </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">const</span> Point2f dst[], </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">int</span> solveMethod = DECOMP_LU</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>参数解释：</p><ul><li>src[]：输入点数组</li><li>dst[]：输出点数组</li><li>solveMethod：传递给cv::solve(DecompTypes) 解决一个或多个线性系统或最小二乘问题，DECOMP_LU是默认值。有关DecompTypes源代码是（解释已附在注释中）：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DecompTypes</span> &#123;</span></span><br><span class="line">    <span class="comment">/** Gaussian elimination with the optimal pivot element chosen. */</span></span><br><span class="line">    DECOMP_LU       = <span class="number">0</span>,<span class="comment">//最佳主轴元素的高斯消元法</span></span><br><span class="line">    <span class="comment">/** singular value decomposition (SVD) method; the system can be over-defined and/or the matrix</span></span><br><span class="line"><span class="comment">    src1 can be singular */</span></span><br><span class="line">    DECOMP_SVD      = <span class="number">1</span>,<span class="comment">//奇异值分解(SVD)方法</span></span><br><span class="line">    <span class="comment">/** eigenvalue decomposition; the matrix src1 must be symmetrical */</span></span><br><span class="line">    DECOMP_EIG      = <span class="number">2</span>,<span class="comment">//特征值分解法</span></span><br><span class="line">    <span class="comment">/** Cholesky \f$LL^T\f$ factorization; the matrix src1 must be symmetrical and positively</span></span><br><span class="line"><span class="comment">    defined */</span></span><br><span class="line">    DECOMP_CHOLESKY = <span class="number">3</span>,<span class="comment">//Cholesky分解法</span></span><br><span class="line">    <span class="comment">/** QR factorization; the system can be over-defined and/or the matrix src1 can be singular */</span></span><br><span class="line">    DECOMP_QR       = <span class="number">4</span>,<span class="comment">//QR分解法</span></span><br><span class="line">    <span class="comment">/** while all the previous flags are mutually exclusive, this flag can be used together with</span></span><br><span class="line"><span class="comment">    any of the previous; it means that the normal equations</span></span><br><span class="line"><span class="comment">    \f$\texttt&#123;src1&#125;^T\cdot\texttt&#123;src1&#125;\cdot\texttt&#123;dst&#125;=\texttt&#123;src1&#125;^T\texttt&#123;src2&#125;\f$ are</span></span><br><span class="line"><span class="comment">    solved instead of the original system</span></span><br><span class="line"><span class="comment">    \f$\texttt&#123;src1&#125;\cdot\texttt&#123;dst&#125;=\texttt&#123;src2&#125;\f$ */</span></span><br><span class="line">    DECOMP_NORMAL   = <span class="number">16</span><span class="comment">//使用正规方程公式，可以去前面的标志一起使用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>重载二函数定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Mat <span class="title">getPerspectiveTransform</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">InputArray src, <span class="comment">//输入图像</span></span></span></span><br><span class="line"><span class="params"><span class="function">InputArray dst, <span class="comment">//输出图像</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">int</span> solveMethod = DECOMP_LU<span class="comment">//同上</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><h1 id="warpPerspective函数"><a href="#warpPerspective函数" class="headerlink" title="warpPerspective函数"></a>warpPerspective函数</h1><p>函数作用：对图像进行透视变换<br>函数定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">warpPerspective</span><span class="params">( </span></span></span><br><span class="line"><span class="params"><span class="function">InputArray src, </span></span></span><br><span class="line"><span class="params"><span class="function">OutputArray dst,</span></span></span><br><span class="line"><span class="params"><span class="function">    InputArray M, </span></span></span><br><span class="line"><span class="params"><span class="function">    Size dsize,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> flags = INTER_LINEAR,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> borderMode = BORDER_CONSTANT,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> Scalar&amp; borderValue = Scalar()</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br></pre></td></tr></table></figure><p>参数解释：</p><ul><li>src：Mat类，输入图像</li><li>dst：Mat类，透视变换后输出图像，与src数据类型相同</li><li>M：透视变换矩阵</li><li>dsize：输出图像大小</li><li>flags：插值方法标志，源代码：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">InterpolationFlags</span>&#123;</span></span><br><span class="line">    <span class="comment">/** nearest neighbor interpolation */</span></span><br><span class="line">    INTER_NEAREST        = <span class="number">0</span>,</span><br><span class="line">    <span class="comment">/** bilinear interpolation */</span></span><br><span class="line">    INTER_LINEAR         = <span class="number">1</span>,</span><br><span class="line">    <span class="comment">/** bicubic interpolation */</span></span><br><span class="line">    INTER_CUBIC          = <span class="number">2</span>,</span><br><span class="line">    <span class="comment">/** resampling using pixel area relation. It may be a preferred method for image decimation, as</span></span><br><span class="line"><span class="comment">    it gives moire&#x27;-free results. But when the image is zoomed, it is similar to the INTER_NEAREST</span></span><br><span class="line"><span class="comment">    method. */</span></span><br><span class="line">    INTER_AREA           = <span class="number">3</span>,</span><br><span class="line">    <span class="comment">/** Lanczos interpolation over 8x8 neighborhood */</span></span><br><span class="line">    INTER_LANCZOS4       = <span class="number">4</span>,</span><br><span class="line">    <span class="comment">/** Bit exact bilinear interpolation */</span></span><br><span class="line">    INTER_LINEAR_EXACT = <span class="number">5</span>,</span><br><span class="line">    <span class="comment">/** Bit exact nearest neighbor interpolation. This will produce same results as</span></span><br><span class="line"><span class="comment">    the nearest neighbor method in PIL, scikit-image or Matlab. */</span></span><br><span class="line">    INTER_NEAREST_EXACT  = <span class="number">6</span>,</span><br><span class="line">    <span class="comment">/** mask for interpolation codes */</span></span><br><span class="line">    INTER_MAX            = <span class="number">7</span>,</span><br><span class="line">    <span class="comment">/** flag, fills all of the destination image pixels. If some of them correspond to outliers in the</span></span><br><span class="line"><span class="comment">    source image, they are set to zero */</span></span><br><span class="line">    WARP_FILL_OUTLIERS   = <span class="number">8</span>,</span><br><span class="line">    <span class="comment">/** flag, inverse transformation</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    For example, #linearPolar or #logPolar transforms:</span></span><br><span class="line"><span class="comment">    - flag is __not__ set: \f$dst( \rho , \phi ) = src(x,y)\f$</span></span><br><span class="line"><span class="comment">    - flag is set: \f$dst(x,y) = src( \rho , \phi )\f$</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    WARP_INVERSE_MAP     = <span class="number">16</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>borderMode：像素边界外推方法的标志，源代码：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">BorderTypes</span> &#123;</span></span><br><span class="line">    BORDER_CONSTANT    = <span class="number">0</span>, <span class="comment">//!&lt; `iiiiii|abcdefgh|iiiiiii`  with some specified `i`</span></span><br><span class="line">    BORDER_REPLICATE   = <span class="number">1</span>, <span class="comment">//!&lt; `aaaaaa|abcdefgh|hhhhhhh`</span></span><br><span class="line">    BORDER_REFLECT     = <span class="number">2</span>, <span class="comment">//!&lt; `fedcba|abcdefgh|hgfedcb`</span></span><br><span class="line">    BORDER_WRAP        = <span class="number">3</span>, <span class="comment">//!&lt; `cdefgh|abcdefgh|abcdefg`</span></span><br><span class="line">    BORDER_REFLECT_101 = <span class="number">4</span>, <span class="comment">//!&lt; `gfedcb|abcdefgh|gfedcba`</span></span><br><span class="line">    BORDER_TRANSPARENT = <span class="number">5</span>, <span class="comment">//!&lt; `uvwxyz|abcdefgh|ijklmno`</span></span><br><span class="line"></span><br><span class="line">    BORDER_REFLECT101  = BORDER_REFLECT_101, <span class="comment">//!&lt; same as BORDER_REFLECT_101</span></span><br><span class="line">    BORDER_DEFAULT     = BORDER_REFLECT_101, <span class="comment">//!&lt; same as BORDER_REFLECT_101</span></span><br><span class="line">    BORDER_ISOLATED    = <span class="number">16</span> <span class="comment">//!&lt; do not look outside of ROI</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>Scalar&amp; borderValue：边界的颜色设置，一般默认是0<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1>目的：将原图中斜放的♠K进行透视变换得到鸟瞰图。<br>原图如下：<br><img src="https://img-blog.csdnimg.cn/637774e2fb5042ff846e5ccc48d110a1.jpg#pic_center"><br>源代码：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;opencv_world453d.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;opencv_world453.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// _DEBUG</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/********************将一张斜放的扑克牌生成鸟瞰图*********************/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mat transMatrix, imgOut;</span><br><span class="line">    <span class="keyword">float</span> cardWidth = <span class="number">250</span>;</span><br><span class="line">    <span class="keyword">float</span> cardHeight = <span class="number">350</span>;</span><br><span class="line">    string path = <span class="string">&quot;D:\\My Bags\\图片\\cards.jpg&quot;</span>;</span><br><span class="line">    Mat imgIn = <span class="built_in">imread</span>(path);<span class="comment">//读取原图像</span></span><br><span class="line">    Point2f srcPoint[<span class="number">4</span>] = &#123; &#123;<span class="number">530</span>,<span class="number">143</span>&#125;,&#123;<span class="number">773</span>,<span class="number">193</span>&#125;,&#123;<span class="number">403</span>,<span class="number">394</span>&#125;, &#123;<span class="number">674</span>,<span class="number">455</span>&#125; &#125;;<span class="comment">//原图中框定四个点</span></span><br><span class="line">    Point2f dstPoint[<span class="number">4</span>] = &#123; &#123;<span class="number">0.0f</span>,<span class="number">0.0f</span>&#125;,&#123;cardWidth,<span class="number">0.0f</span>&#125;,&#123;<span class="number">0.0f</span>,cardHeight&#125;, &#123;cardWidth,cardHeight&#125; &#125;;<span class="comment">//分别对应鸟瞰图四个点</span></span><br><span class="line">    transMatrix = <span class="built_in">getPerspectiveTransform</span>(srcPoint, dstPoint);<span class="comment">//得到透视变换的矩阵</span></span><br><span class="line">    <span class="built_in">warpPerspective</span>(imgIn, imgOut, transMatrix, <span class="built_in">Size</span>(cardWidth, cardHeight));<span class="comment">//进行透视扭曲</span></span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;原图&quot;</span>, imgIn);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;鸟瞰图&quot;</span>, imgOut);</span><br><span class="line">    <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br>原图<br><img src="https://img-blog.csdnimg.cn/0aa206f9b1c94f1bb40560a215032058.png#pic_center" alt="原图"><br>♠K鸟瞰图：<br><img src="https://img-blog.csdnimg.cn/c4907eda09ca47398090c9342c3a1165.png#pic_center" alt="鸟瞰图"></p>]]></content>
      
      
      <categories>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【OpenCV入门】调整图像大小/裁剪图像</title>
      <link href="/2021/10/03/%E3%80%90OpenCV%E5%85%A5%E9%97%A8%E3%80%91%E8%B0%83%E6%95%B4%E5%9B%BE%E5%83%8F%E5%A4%A7%E5%B0%8F-%E8%A3%81%E5%89%AA%E5%9B%BE%E5%83%8F/"/>
      <url>/2021/10/03/%E3%80%90OpenCV%E5%85%A5%E9%97%A8%E3%80%91%E8%B0%83%E6%95%B4%E5%9B%BE%E5%83%8F%E5%A4%A7%E5%B0%8F-%E8%A3%81%E5%89%AA%E5%9B%BE%E5%83%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="调整图像大小-resize"><a href="#调整图像大小-resize" class="headerlink" title="调整图像大小-resize"></a>调整图像大小-resize</h1><h2 id="函数resize"><a href="#函数resize" class="headerlink" title="函数resize"></a>函数resize</h2><p>函数的定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">( InputArray src, <span class="comment">//输入图像</span></span></span></span><br><span class="line"><span class="params"><span class="function"> OutputArray dst,<span class="comment">//输出图像</span></span></span></span><br><span class="line"><span class="params"><span class="function">             Size dsize, <span class="comment">//调整成的大小</span></span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="keyword">double</span> fx = <span class="number">0</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="keyword">double</span> fy = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="keyword">int</span> interpolation = INTER_LINEAR </span></span></span><br><span class="line"><span class="params"><span class="function">             )</span></span>;</span><br></pre></td></tr></table></figure><p>参数解释：</p><ul><li>src：输入的图像，Mat类</li><li>dst：输出的图像，当参数dsize不为0时，dst的大小由dsize决定；否则，它的大小由参数fx和fy决定</li><li>dsize：输出图像的大小，写成Size(宽，高)（单位：像素）</li><li>fx和fy：水平/竖直方向上的缩放比例</li><li>interpolation：插值方法。取值如下：<br> INTER_NEAREST———最近邻插值<br> INTER_LINEAR———双线性插值（默认设置）<br> INTER_AREA———使用像素区域关系进行重采样<br> INTER_CUBIC———4x4像素邻域的双三次插值<br> INTER_LANCZOS4———8x8像素邻域的Lanczos插值</li><li>注意：参数dsize和参数(fx, fy)不能够同时为0<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2>源代码：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;opencv_world453d.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;opencv_world453.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// _DEBUG</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mat img = <span class="built_in">imread</span>(<span class="string">&quot;D:\\My Bags\\图片\\Test.jpg&quot;</span>);</span><br><span class="line">    Mat outImg;</span><br><span class="line">    <span class="built_in">resize</span>(img, outImg, <span class="built_in">Size</span>(<span class="number">0</span>,<span class="number">0</span>), <span class="number">0.8</span>, <span class="number">0.8</span>);<span class="comment">//宽和高都变为原来的0.8倍</span></span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;原图&quot;</span>, img);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;改变尺寸后&quot;</span>, outImg);</span><br><span class="line">    <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="https://img-blog.csdnimg.cn/655518d39adf4e9ea37489b75c854dff.bmp#pic_center"></p><h1 id="裁剪图像"><a href="#裁剪图像" class="headerlink" title="裁剪图像"></a>裁剪图像</h1><h2 id="Rect类"><a href="#Rect类" class="headerlink" title="Rect类"></a>Rect类</h2><p>先创建一个Rect对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Rect</span>(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> width, <span class="keyword">int</span> height);</span><br></pre></td></tr></table></figure><p>参数解释：</p><ul><li>前两个x，y：矩形左上角相对图像的坐标</li><li>后两个width，height：矩形的宽和高</li><li>单位都是像素，坐标轴如下图：<br><img src="https://img-blog.csdnimg.cn/05b11a1e6a4f4b569584bac445844279.bmp#pic_center"><br>图像Mat类对象(Rect 对象) 就可以返回一个裁剪了对应矩形区域的Mat类图像<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2>源代码：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;opencv_world453d.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;opencv_world453.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// _DEBUG</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mat img = <span class="built_in">imread</span>(<span class="string">&quot;D:\\My Bags\\图片\\Test.jpg&quot;</span>);</span><br><span class="line">    <span class="function">Rect <span class="title">cropArea</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">150</span>, <span class="number">200</span>)</span></span>;</span><br><span class="line">    Mat outImg = <span class="built_in">img</span>(cropArea);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;原图&quot;</span>, img);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;裁剪后&quot;</span>, outImg);</span><br><span class="line">    <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="https://img-blog.csdnimg.cn/e16b63d194c842d8baef96d18b738b1f.bmp#pic_center"></p>]]></content>
      
      
      <categories>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【OpenCV入门】一些基本的图像处理</title>
      <link href="/2021/10/02/%E3%80%90OpenCV%E5%85%A5%E9%97%A8%E3%80%91%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
      <url>/2021/10/02/%E3%80%90OpenCV%E5%85%A5%E9%97%A8%E3%80%91%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<hr><p>我的个人博客：<a href="https://oceanbloom.github.io/">谋仁·Blog</a><br>微信公众号：谋仁的麻袋</p><hr><h1 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h1><h2 id="颜色空间"><a href="#颜色空间" class="headerlink" title="颜色空间"></a>颜色空间</h2><p>为了表示一种特定的颜色，我们通常建立一维、二维、三维甚至四维空间坐标来表示，这种坐标系统所能定义的色彩范围即颜色空间。下面列举常见的颜色空间：</p><ul><li><p>RGB模型<br> RGB模型将颜色编码成（R，G，B）即（Red红，Green绿，Blue蓝）。每个分量范围是[0,255]共256级。因此，RGB模型可以表示256×256×256≈1670万种颜色。<br> <strong>注意：在OpenCV中存储顺序不是RGB，而是BGR。</strong></p></li><li><p>单通道模型<br> 单通道图即灰度图，图片像素颜色由一维的值来表示，分量范围是[0,255]。0是黑色，255是白色，中间是不同程度的灰色。</p></li><li><p>二值模型<br>  二值图像即黑白图像，每个像素的颜色由一维的值来表示，分量范围是[0,1]，0代表黑色，1代表白色。</p></li><li><p>HSV模型<br> HSV模型由三个参数来表示颜色：色调（H）、饱和度（S）、明度（V）。<br> 色调（H）用角度表示，范围[0°,360°]，红色为0°，从红色开始按逆时针方向计算。（如下图）<br> 饱和度（S）表示颜色接近光谱色的程度，饱和度越高，颜色越深而艳。取值范围[0%,100%]。<br> 明度（V）表示颜色鲜亮的程度，取值范围[0%,100%]，0%为黑色，100%为白色。<br> <img src="https://img-blog.csdnimg.cn/814b3689223f4c409980fa3606e77793.png#pic_center" alt="HSV模型图示"></p></li><li><p>Lab模型<br> Lab颜色空间中的L分量用于表示像素的亮度，取值范围是[0,100],表示从纯黑到纯白；a表示从红色到绿色的范围，取值范围是[127,-128]；b表示从黄色到蓝色的范围，取值范围是[127,-128]。图示如下：<br> <img src="https://img-blog.csdnimg.cn/83e3e6ac7d354842a9d0b1a0a89d91be.png#pic_center" alt="Lab模型"></p><h2 id="图像的深度"><a href="#图像的深度" class="headerlink" title="图像的深度"></a>图像的深度</h2><p>图像用于存储像素的值占得比特（bit）位数（就是转换为二进制的位数），就是图像的深度。例如：在二值模型中每个像素点的值是一维的，且取值范围是[0,1]，所以仅用一位比特位就可以满足，图像深度为1；RGB模型中每个像素用R,G,B三个分量表示，每个分量取值范围[0,255]，用8位可以表示，所以像素深度总共为24位。</p><h2 id="图像通道"><a href="#图像通道" class="headerlink" title="图像通道"></a>图像通道</h2><p>为了储存像素数据，每一个像素点用一个或多个分量来存储数据，分量的数量就是图像通道。例如，RGB模式中每个像素点由Red、Dreen、Blue三个分量来表示，每个取值范围都是[0,255]，这个图像通道就是3。灰度图仅用一个取值范围为[0,255]数值来表示，灰度图的图像通道就是1。</p><h1 id="颜色空间的转换-cvtColor"><a href="#颜色空间的转换-cvtColor" class="headerlink" title="颜色空间的转换-cvtColor"></a>颜色空间的转换-cvtColor</h1><h2 id="函数cvtColor"><a href="#函数cvtColor" class="headerlink" title="函数cvtColor"></a>函数cvtColor</h2><p>cv::cvtColor()作用是将图像从一个颜色空间转换到另一个颜色空间。并且在转换的过程中能够保证数据的类型不变，即转换后的图像的数据类型和位深与源图像一致。<br>函数定义：</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cv::cvtColor</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      cv::InputArray src, <span class="comment">// 输入图像</span></span></span></span><br><span class="line"><span class="params"><span class="function">      cv::OutputArray dst, <span class="comment">// 输出图像</span></span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">int</span> code, <span class="comment">// 模式转换的映射码</span></span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">int</span> dstCn = <span class="number">0</span> <span class="comment">// 输出的通道数 (0=&#x27;automatic&#x27;)</span></span></span></span><br><span class="line"><span class="params"><span class="function">     )</span></span>;</span><br></pre></td></tr></table></figure><ul><li>src： Mat类，输入待转换的图像</li><li>dst：Mat类，转换后新图像放在这里</li><li>code：转换的代码或标识，即图像转换的格式（模式1→模式2）<br>  OpenCV提供的映射：<br>  <img src="https://img-blog.csdn.net/20180717150512898"></li><li>dstCn：（默认是0）目标图像通道数，如果取值为0，则由src和code决定<h2 id="示例（BGR转换成灰度图）"><a href="#示例（BGR转换成灰度图）" class="headerlink" title="示例（BGR转换成灰度图）"></a>示例（BGR转换成灰度图）</h2>源代码：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;opencv_world453d.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;opencv_world453.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// _DEBUG</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mat img = <span class="built_in">imread</span>(<span class="string">&quot;D:\\My Bags\\图片\\Test.jpg&quot;</span>);</span><br><span class="line">    Mat imgGray;</span><br><span class="line">    <span class="built_in">cvtColor</span>(img, imgGray, COLOR_BGR2GRAY);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;原图&quot;</span>, img);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;灰度图&quot;</span>, imgGray);</span><br><span class="line">    <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="https://img-blog.csdnimg.cn/34b15ecab7554d9c9c0c3e976a3c1103.bmp#pic_center"></p><h1 id="高斯滤波-GaussianBlur"><a href="#高斯滤波-GaussianBlur" class="headerlink" title="高斯滤波-GaussianBlur"></a>高斯滤波-GaussianBlur</h1><h2 id="函数GaussianBlur"><a href="#函数GaussianBlur" class="headerlink" title="函数GaussianBlur"></a>函数GaussianBlur</h2><p>函数的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GaussianBlur</span><span class="params">( InputArray src, <span class="comment">//输入的图像</span></span></span></span><br><span class="line"><span class="params"><span class="function">   OutputArray dst, <span class="comment">//接收输出的图像</span></span></span></span><br><span class="line"><span class="params"><span class="function">   Size ksize,<span class="comment">//高斯内核大小</span></span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">double</span> sigmaX, </span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">double</span> sigmaY = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">int</span> borderType = BORDER_DEFAULT)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>src：Mat类，输入待处理的图像</li><li>dst：Mat类，输出与原图大小和类型相同的图像</li><li>ksize：高斯内核的大小，决定了滤波的程度。其中ksize.width和ksize.height可以不同，但他们都必须为正数和奇数。或者，它们可以是零的，它们都是由sigma计算而来</li><li>sigmaX：高斯核函数在X方向上的标准偏差</li><li>sigmaY：高斯核函数在Y方向上的标准偏差，如果sigmaY是0，则函数会自动将sigmaY的值设置为与sigmaX相同的值，如果sigmaX和sigmaY都是0，这两个值将由ksize.width和ksize.height计算而来</li><li>borderType：推断图像外部像素的某种便捷模式，有默认值BORDER_DEFAULT，如果没有特殊需要不用更改<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2>源代码：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;opencv_world453d.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;opencv_world453.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// _DEBUG</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mat img = <span class="built_in">imread</span>(<span class="string">&quot;D:\\My Bags\\图片\\Test.jpg&quot;</span>);</span><br><span class="line">    Mat imgGaus;</span><br><span class="line">    <span class="built_in">GaussianBlur</span>(img, imgGaus, <span class="built_in">Size</span>(<span class="number">7</span>, <span class="number">7</span>), <span class="number">7</span>);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;原图&quot;</span>, img);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;高斯滤波图&quot;</span>, imgGaus);</span><br><span class="line">    <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="https://img-blog.csdnimg.cn/1eed8f1eaa08470db519e49b0fceb2b3.bmp#pic_center"></p><h1 id="图像边缘检测-Canny"><a href="#图像边缘检测-Canny" class="headerlink" title="图像边缘检测-Canny"></a>图像边缘检测-Canny</h1><h2 id="函数Canny"><a href="#函数Canny" class="headerlink" title="函数Canny"></a>函数Canny</h2><p>函数定义</p><p>重载1：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Canny</span><span class="params">( InputArray image,<span class="comment">//输入图像</span></span></span></span><br><span class="line"><span class="params"><span class="function">    OutputArray edges,<span class="comment">//输出图像</span></span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">double</span> threshold1, <span class="comment">//阈值1</span></span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">double</span> threshold2,<span class="comment">//阈值2</span></span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">int</span> apertureSize = <span class="number">3</span>, <span class="comment">//Sober算子大小</span></span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">bool</span> L2gradient = <span class="literal">false</span> <span class="comment">//是否采用更精确的方式计算图像梯度</span></span></span></span><br><span class="line"><span class="params"><span class="function">            )</span></span>;</span><br></pre></td></tr></table></figure><p>两个阈值参数：</p><ul><li>低于阈值1的像素点会被认为不是边缘；</li><li>高于阈值2的像素点会被认为是边缘；</li><li>在阈值1和阈值2之间的像素点,若与第2步得到的边缘像素点相邻，则被认为是边缘，否则被认为不是边缘</li><li>建议上限是下限的2或3倍</li></ul><p>apertureSize参数：</p><ul><li>为Sobel()运算提供内核大小，默认值为3</li></ul><p>重载2：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Canny</span><span class="params">( InputArray dx, </span></span></span><br><span class="line"><span class="params"><span class="function">InputArray dy,</span></span></span><br><span class="line"><span class="params"><span class="function">            OutputArray edges,<span class="comment">//输出图像</span></span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">double</span> threshold1, <span class="comment">//下阈值</span></span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">double</span> threshold2,<span class="comment">//上阈值</span></span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">bool</span> L2gradient = <span class="literal">false</span> </span></span></span><br><span class="line"><span class="params"><span class="function">            )</span></span>;</span><br></pre></td></tr></table></figure><ul><li>InputArray dx：输入图像在x方向的导数</li><li>InputArray dy：输入图像在y方向的导数<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2>源代码</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;opencv_world453d.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;opencv_world453.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// _DEBUG</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mat img = <span class="built_in">imread</span>(<span class="string">&quot;D:\\My Bags\\图片\\Test.jpg&quot;</span>);</span><br><span class="line">    Mat imgGaus,imgEdge;</span><br><span class="line">    <span class="built_in">GaussianBlur</span>(img, imgGaus, <span class="built_in">Size</span>(<span class="number">3</span>, <span class="number">3</span>), <span class="number">3</span>);<span class="comment">//高斯滤波降噪</span></span><br><span class="line">    <span class="built_in">Canny</span>(imgGaus, imgEdge, <span class="number">100</span>, <span class="number">300</span>);<span class="comment">//边缘检测</span></span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;原图&quot;</span>, img);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;边缘图&quot;</span>, imgEdge);</span><br><span class="line">    <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="https://img-blog.csdnimg.cn/d386fa78005b4190855afbc6b41bfc3e.bmp#pic_center"></p><h1 id="图像的膨胀和侵蚀-dilate和erode"><a href="#图像的膨胀和侵蚀-dilate和erode" class="headerlink" title="图像的膨胀和侵蚀-dilate和erode"></a>图像的膨胀和侵蚀-dilate和erode</h1><h2 id="函数dilate-erode"><a href="#函数dilate-erode" class="headerlink" title="函数dilate/erode"></a>函数dilate/erode</h2><p>dilate函数的定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dilate</span><span class="params">( InputArray src, </span></span></span><br><span class="line"><span class="params"><span class="function"> OutputArray dst, </span></span></span><br><span class="line"><span class="params"><span class="function"> InputArray kernel,</span></span></span><br><span class="line"><span class="params"><span class="function">             Point anchor = Point(<span class="number">-1</span>,<span class="number">-1</span>), </span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="keyword">int</span> iterations = <span class="number">1</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="keyword">int</span> borderType = BORDER_CONSTANT,</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="keyword">const</span> Scalar&amp; borderValue = morphologyDefaultBorderValue() </span></span></span><br><span class="line"><span class="params"><span class="function">             )</span></span>;</span><br></pre></td></tr></table></figure><p>erode函数的定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">erode</span><span class="params">( InputArray src, </span></span></span><br><span class="line"><span class="params"><span class="function">            OutputArray dst, </span></span></span><br><span class="line"><span class="params"><span class="function">            InputArray kernel,</span></span></span><br><span class="line"><span class="params"><span class="function">            Point anchor = Point(<span class="number">-1</span>,<span class="number">-1</span>), </span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">int</span> iterations = <span class="number">1</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">int</span> borderType = BORDER_CONSTANT,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">const</span> Scalar&amp; borderValue = morphologyDefaultBorderValue() </span></span></span><br><span class="line"><span class="params"><span class="function">            )</span></span>;</span><br></pre></td></tr></table></figure><p>两个函数参数完全一样，参数解释：</p><ul><li>src：Mat类，输入的原图</li><li>dst：Mat类，用于存放处理后的图像</li><li>kernel：用于膨胀/侵蚀操作的结构元素，当为NULL时,那么默认使用一个3 x 3 的方形结构元素，可以使用getStructuringElement()（下文有详细介绍）来创建结构元素</li><li>anchor：结构元素的锚点位置，默认值value(-1,-1)表示锚点位于结构元素中心</li><li>iterations：进行膨胀/侵蚀操作迭代执行的次数，默认是1</li><li>borderType：用于推断图像外部像素的某种推断模式。默认值BORDER_CONSTANT</li><li>Scalar&amp; borderValue：边缘值，默认值morphologyDefaultBorderValue()。一般不用改动<h2 id="补充：函数getStructuringElement"><a href="#补充：函数getStructuringElement" class="headerlink" title="补充：函数getStructuringElement"></a>补充：函数getStructuringElement</h2>函数的定义：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Mat <span class="title">getStructuringElement</span><span class="params">(<span class="keyword">int</span> shape, </span></span></span><br><span class="line"><span class="params"><span class="function">  Size ksize, </span></span></span><br><span class="line"><span class="params"><span class="function">  Point anchor = Point(<span class="number">-1</span>,<span class="number">-1</span>)</span></span></span><br><span class="line"><span class="params"><span class="function">  )</span></span>;</span><br></pre></td></tr></table></figure><p>作用：返回（Mat类型）指定形状和尺寸的结构元素</p><p>参数解释：</p><ul><li>shape：结构元素的形状<br> 矩形：MORPH_RECT;<br> 交叉形：MORPH_CROSS;<br> 椭圆形：MORPH_ELLIPSE;</li><li>ksize：结构元素的尺寸，同GaussianBlur函数的ksize</li><li>anchor：锚点的位置，默认值Point（-1,-1），表示锚点位于中心点</li></ul><h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h2><p>源代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;opencv_world453d.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;opencv_world453.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// _DEBUG</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mat imgDilate, imgErode;</span><br><span class="line">    Mat img = <span class="built_in">imread</span>(<span class="string">&quot;D:\\My Bags\\图片\\Test.jpg&quot;</span>);</span><br><span class="line">    Mat kernel = <span class="built_in">getStructuringElement</span>(MORPH_RECT, <span class="built_in">Size</span>(<span class="number">5</span>, <span class="number">5</span>));<span class="comment">//新建一个结构元素</span></span><br><span class="line">    <span class="built_in">dilate</span>(img, imgDilate, kernel);<span class="comment">//膨胀操作</span></span><br><span class="line">    <span class="built_in">erode</span>(img, imgErode, kernel);<span class="comment">//侵蚀操作</span></span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;原图&quot;</span>, img);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;膨胀图&quot;</span>, imgDilate);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;侵蚀图&quot;</span>, imgErode);</span><br><span class="line">    <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="https://img-blog.csdnimg.cn/52b86a0dd21146d1b8ad879def89261d.bmp#pic_center"></p>]]></content>
      
      
      <categories>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【OpenCV入门】读取图片/视频/调用摄像头</title>
      <link href="/2021/09/30/%E3%80%90OpenCV%E5%85%A5%E9%97%A8%E3%80%91%E8%AF%BB%E5%8F%96%E5%9B%BE%E7%89%87-%E8%A7%86%E9%A2%91-%E8%B0%83%E7%94%A8%E6%91%84%E5%83%8F%E5%A4%B4/"/>
      <url>/2021/09/30/%E3%80%90OpenCV%E5%85%A5%E9%97%A8%E3%80%91%E8%AF%BB%E5%8F%96%E5%9B%BE%E7%89%87-%E8%A7%86%E9%A2%91-%E8%B0%83%E7%94%A8%E6%91%84%E5%83%8F%E5%A4%B4/</url>
      
        <content type="html"><![CDATA[<hr><p>我的个人博客：<a href="https://oceanbloom.github.io/">谋仁·Blog</a><br>公众号：谋仁的麻袋</p><hr><h1 id="读取图片"><a href="#读取图片" class="headerlink" title="读取图片"></a>读取图片</h1><ul><li>预期效果：从指定路径读取一张图片并显示出来。</li><li>源代码：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span><span class="comment">//输入输出流</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="comment">//c++标准库</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;opencv_world453d.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;opencv_world453.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// _DEBUG</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">string path = <span class="string">&quot;Resources/test.png&quot;</span>;<span class="comment">//相对路径</span></span><br><span class="line">Mat outImg=<span class="built_in">imread</span>(path);<span class="comment">//从指定路径读取图片信息</span></span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;图片&quot;</span>, outImg);<span class="comment">//将图片显示出来</span></span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">0</span>);<span class="comment">//参数为0时暂停时间是无穷</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>必要的补充：</p><ul><li><p>cv::Mat cv::imread(const cv::String &amp;filename,int flags);<br>  作用：从一个文件中加载一张图片。<br>  输入参数1：const string类型，图片文件的路径（带文件名及后缀）。<br>  输入参数2：int类型，读取的格式，<a href="https://blog.csdn.net/z914022466/article/details/52709981">具体参考这里</a><br>  返回：Mat对象（Mat类型是用于存储图像信息的矩阵）。</p></li><li><p>void cv::imshow(const cv::string &amp;winname,cv::InputArray mat);<br> 作用：将图片显示在窗口中。<br> 输入参数1：const string类型，窗口的名称。<br> 输出参数2：mat类型，待输出的图片。<br> 返回：空</p></li><li><p>int cv::waitKey(int delay);<br>  作用：延时函数，如果延时期间有按键按下则立即结束并返回按键的ASCII码。当参数delay=0，程序一直延时，直到有按键按下去；当参数delay&gt;0，则程序延时delay毫秒，并同时等待按键按下。<br>  输入参数：int类型，延时的时长；/或选择0一直延时。<br>  返回：返回按键的ASCII码。</p><h1 id="读取视频文件"><a href="#读取视频文件" class="headerlink" title="读取视频文件"></a>读取视频文件</h1><p>视频就是由一张张图片组成的，所以在读取图片的基础上套一个while循环，不断地获取新的图片并显示出来就可以完成视频的读取了。</p></li><li><p>预期效果：从指定路径读取一个视频文件（视频的图像，不包括音频），并播放出来。</p></li><li><p>源代码：</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span><span class="comment">//输入输出流</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="comment">//c++标准库</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;opencv_world453d.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;opencv_world453.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// _DEBUG</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">string path = <span class="string">&quot;Resources/test_video.mp4&quot;</span>;</span><br><span class="line"><span class="function">VideoCapture <span class="title">testVideo</span><span class="params">(path)</span></span>;<span class="comment">//从视频文件的路径读取</span></span><br><span class="line">Mat videoImg;<span class="comment">//接收每一帧读取的图像</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;<span class="comment">//循环不断获取新的图片并显示出来</span></span><br><span class="line">testVideo.<span class="built_in">read</span>(videoImg);<span class="comment">//读取摄像头的照片并存放在Mat类型的videoImg中</span></span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Video&quot;</span>, videoImg);<span class="comment">//将图片显示出来</span></span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">3</span>);<span class="comment">//相邻每帧图片间隔时间（单位：ms</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>必要的补充：</p><ul><li>class cv::VideoCapture<br> 作用：对视频进行读取操作以及调用摄像头。<br> 实例化以后传入string类型的视频文件路径以读取文件；传入int类型接入的指定摄像头的ID以调用指定摄像头。</li></ul><h1 id="调用摄像头"><a href="#调用摄像头" class="headerlink" title="调用摄像头"></a>调用摄像头</h1><p>在读取视频程序的基础上，将VideoCapture类型的实例传进string类型路径换成int类型的摄像头ID后就完成了调用摄像头操作。</p><ul><li>预期效果：调用指定摄像头，窗口中显示摄像头拍到的内容。</li><li>源代码：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span><span class="comment">//输入输出流</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="comment">//c++标准库</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;opencv_world453d.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;opencv_world453.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// _DEBUG</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">VideoCapture <span class="title">testVideo</span><span class="params">(<span class="number">0</span>)</span></span>;<span class="comment">//调用0号摄像头</span></span><br><span class="line">Mat videoImg;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;<span class="comment">//循环不断获取新的图片并显示出来</span></span><br><span class="line">testVideo.<span class="built_in">read</span>(videoImg);<span class="comment">//读取摄像头的照片并存放在Mat类型的videoImg中</span></span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Video&quot;</span>, videoImg);<span class="comment">//将图片显示出来</span></span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">3</span>);<span class="comment">//相邻每帧图片间隔时间（单位：ms</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【C#】值传递、引用传递和string类型的不可变性</title>
      <link href="/2021/09/26/%E3%80%90C-%E3%80%91%E5%80%BC%E4%BC%A0%E9%80%92%E3%80%81%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E5%92%8Cstring%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7/"/>
      <url>/2021/09/26/%E3%80%90C-%E3%80%91%E5%80%BC%E4%BC%A0%E9%80%92%E3%80%81%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E5%92%8Cstring%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h1><p>值类型/引用类型包含有：</p><ul><li>值类型：int、double、bool、char、decimal、struct、enum</li><li>引用类型：string、自定义类、数组、集合、object、接口</li></ul><p>二者的区别：</p><ul><li><p>1、值类型和引用类型在内存上存储的地方不同：</p><p>值类型存储在栈中，引用类型存储在堆中。</p></li><li><p>2、在传递值类型和传递引用类型时，传递方式不同；</p></li></ul><h1 id="值类型的传递"><a href="#值类型的传递" class="headerlink" title="值类型的传递"></a>值类型的传递</h1><p>值类型在传递的时候，传递的是值本身。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> 值传递和引用传递</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> a = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">int</span> b = a;</span><br><span class="line">            b = <span class="number">2</span>;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;a=&#123;0&#125;&quot;</span>,a);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;b=&#123;0&#125;&quot;</span>,b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://img-blog.csdnimg.cn/52a0d4d7e4d046beb4404cedec5e8191.bmp#pic_center"></p><p>内存图：</p><p><img src="https://img-blog.csdnimg.cn/fd13147c6dba45aea6653ce055a25ea0.bmp#pic_center"></p><p>在执行 int b=a; 时，在栈中开辟一块空间用于存储b，并将a中的值传给b。执行完 b=2; 后，b被赋予了新值，并覆盖了原来的值。根据输出结果，值传递后，b的值与a的值无关，互不影响。</p><h1 id="引用类型的传递"><a href="#引用类型的传递" class="headerlink" title="引用类型的传递"></a>引用类型的传递</h1><blockquote><p>注意：这里引用传递的运行结果放在string类型上会有所不同，这是因为string类型具有不可变性，string类型的不可变性在下文会有介绍。</p></blockquote><p>引用类型传递的时候，传递的是对这个对象的引用（即存在堆中的地址）。</p><p>下面以自定义类（Person）来说明：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> 值传递和引用传递</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line">            p1.Name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">            Person p2 = p1;</span><br><span class="line">            p2.Name = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;p1.Name=&#123;0&#125;&quot;</span>,p1.Name);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;p2.Name=&#123;0&#125;&quot;</span>, p2.Name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="built_in">string</span> _name;</span><br><span class="line">            <span class="keyword">public</span> <span class="built_in">string</span> Name</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">get</span> &#123; <span class="keyword">return</span> _name; &#125;</span><br><span class="line">                <span class="keyword">set</span> &#123; _name = <span class="keyword">value</span>; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://img-blog.csdnimg.cn/1e56b4b41da74f2e8b50fd8545f41921.bmp#pic_center"></p><p>内存图：</p><p><img src="https://img-blog.csdnimg.cn/36be77aa33c74a359260815efa7ae71c.bmp#pic_center"></p><p>创建完成p1对象后，在堆上开辟一块存储空间，并将该存储空间的地址放在栈上，栈中这块空间的地址（标识）是p1。当p1对象传递给p2后，只是将对堆中的存储的引用（堆中的地址）复制一份传给p2，完成传递后p1和p2共同指向同一块内存，所以p1或p2中任意一个更改存储内容后，另一个也会改变。</p><h1 id="string类型的不可变性"><a href="#string类型的不可变性" class="headerlink" title="string类型的不可变性"></a>string类型的不可变性</h1><p>先按照上述“引用类型的传递”的思路来看string类型的传递：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> 值传递和引用传递</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> a = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">            <span class="built_in">string</span> b = a;</span><br><span class="line">            b = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;a=&#123;0&#125;&quot;</span>, a);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;b=&#123;0&#125;&quot;</span>, b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://img-blog.csdnimg.cn/3bb582279a9346d4bf9b4f38f8fdbdd9.bmp#pic_center"></p><p>从运行结果可以看出，string类型的传递和一般引用类型不同，这是因为string类型具有不可变性：</p><ul><li>当给一个字符串重新赋值以后，旧值并没有销毁，而是重新开辟了一块空间用于存储新值。</li></ul><p>内存图：</p><p><img src="https://img-blog.csdnimg.cn/041f1ecf1a8e48da83c7924845bcb1f4.bmp#pic_center"></p><p>在a赋值“张三”并传递给b后，根据“引用类型的传递”，a和b共同指向“张三”（如图：堆地址为10001）这块内存。但是，在b重新被赋值为“李四”后，堆中开辟一块空间存储“李四”，旧值“张三”依然存在，新值的堆地址（如图：堆地址为10002）赋给栈中b的存储以使b指向“李四”。至此，a和b就不再指向同一块堆空间了。故运行结果与一般引用类型有所不同。</p>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用C语言实现飞机大战小游戏</title>
      <link href="/2021/09/18/%E7%94%A8C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E9%A3%9E%E6%9C%BA%E5%A4%A7%E6%88%98%E5%B0%8F%E6%B8%B8%E6%88%8F/"/>
      <url>/2021/09/18/%E7%94%A8C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E9%A3%9E%E6%9C%BA%E5%A4%A7%E6%88%98%E5%B0%8F%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<hr><p>我的个人博客：<a href="https://oceanbloom.github.io/">谋仁·Blog</a><br>该项目已上传至GitHub：<a href="https://github.com/OceanBloom/Plane-War-1.0">点击跳转</a></p><hr><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>这是一个用C语言实现的基于EasyX图形库的飞机大战小游戏，很有意思的小项目。对初学者很友好哦！快来看一下吧！</p><h2 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h2><p>Windows10+Visual Studio 2019+EasyX_20210730</p><h2 id="整体功能思维导图"><a href="#整体功能思维导图" class="headerlink" title="整体功能思维导图"></a>整体功能思维导图</h2><p><img src="https://img-blog.csdnimg.cn/705b7fccef5249d8bfbaf86952d54ad9.png"></p><h2 id="效果预览"><a href="#效果预览" class="headerlink" title="效果预览"></a>效果预览</h2><ul><li>菜单界面（此时鼠标指在GO！按钮，按钮发生变色以反馈用户）</li></ul><p><img src="https://img-blog.csdnimg.cn/22274009979c4f89844c8b1c1c194239.png"></p><ul><li>玩法界面（跳出弹窗介绍游戏规则）</li></ul><p><img src="https://img-blog.csdnimg.cn/c8f9f7f75a50430cb3cb48c40c0b3034.png"></p><ul><li>进入游戏界面（敌机在窗体最上端随机出现，玩家移动/发射子弹）</li></ul><p><img src="https://img-blog.csdnimg.cn/c1558985d85c4dae898c5cd662e68308.png"></p><p><img src="https://img-blog.csdnimg.cn/6ebe4b94ebf34924ac15b06d3da8a282.png"></p><ul><li>游戏结束</li></ul><p><img src="https://img-blog.csdnimg.cn/93e6ddf7918d48f6bff55fc3de4ace48.png"></p><h1 id="具体功能的实现"><a href="#具体功能的实现" class="headerlink" title="具体功能的实现"></a>具体功能的实现</h1><h2 id="图形界面：EasyX"><a href="#图形界面：EasyX" class="headerlink" title="图形界面：EasyX"></a>图形界面：EasyX</h2><h3 id="EasyX图形库简介"><a href="#EasyX图形库简介" class="headerlink" title="EasyX图形库简介"></a>EasyX图形库简介</h3><ul><li>EasyX Graphics Library 是针对 Visual C++ 的免费绘图库，因其学习成本低、易上手、应用范围广、功能丰富等特点广受欢迎。</li><li>我们学习C语言面对着黑框，枯燥又乏味。想要做一些图形编程，但很多图形库学习难度大，学习门槛高，如：Win32,OpenlGI等。这时候我们就可以使用EasyX图形库来做一些图形编程，既简单又有趣。</li></ul><h3 id="EasyX图形库的一些基本功能（该项目用到的）"><a href="#EasyX图形库的一些基本功能（该项目用到的）" class="headerlink" title="EasyX图形库的一些基本功能（该项目用到的）"></a>EasyX图形库的一些基本功能（该项目用到的）</h3><ul><li><p>如何让一张图片显现出来？分三步：</p><ul><li><p>绘制窗体–initgraph</p><p>例1：绘制一个宽×高为1522×787（该项目的窗口大小，单位：像素）的窗口。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">initgraph(<span class="number">1522</span>, <span class="number">787</span>);</span><br></pre></td></tr></table></figure><p>例2：绘制一个宽×高为1522×787的窗口，同时显示控制台窗口。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">initgraph(<span class="number">1522</span>, <span class="number">787</span>, EW_SHOWCONSOLE);</span><br></pre></td></tr></table></figure><p>显示控制台窗口便于调试。</p></li><li><p>加载图片–loadimage</p><p>例：将菜单界面背景图加载出来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IMAGE menuBackground;<span class="comment">//存放游戏菜单界面背景图</span></span><br><span class="line">loadimage(&amp;menuBackground, <span class="string">&quot;./资源/menuBackground.png&quot;</span>);<span class="comment">//加载背景图</span></span><br></pre></td></tr></table></figure></li><li><p>粘贴图片–putimage</p><p>例：将加载好的菜单界面背景图片显示出来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">putimage(<span class="number">0</span>, <span class="number">0</span>, &amp;menuBackground);</span><br></pre></td></tr></table></figure><p>注：前两个参数分别表示横坐标、纵坐标。这里的坐标轴是以窗体左上角为原点。横坐标是操作对象的左上角到窗体左边的垂直距离，纵坐标是操作对象到窗体上边的垂直距离。</p></li></ul></li><li><p>关于颜色</p><ul><li><p>已经预定义的颜色</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">常量值颜色</span><br><span class="line">------------------------</span><br><span class="line">BLACK<span class="number">0</span>黑</span><br><span class="line">BLUE<span class="number">0xAA0000</span>蓝</span><br><span class="line">GREEN<span class="number">0x00AA00</span>绿</span><br><span class="line">CYAN<span class="number">0xAAAA00</span>青</span><br><span class="line">RED<span class="number">0x0000AA</span>红</span><br><span class="line">MAGENTA<span class="number">0xAA00AA</span>紫</span><br><span class="line">BROWN<span class="number">0x0055AA</span>棕</span><br><span class="line">LIGHTGRAY<span class="number">0xAAAAAA</span>浅灰</span><br><span class="line">DARKGRAY<span class="number">0x555555</span>深灰</span><br><span class="line">LIGHTBLUE<span class="number">0xFF5555</span>亮蓝</span><br><span class="line">LIGHTGREEN<span class="number">0x55FF55</span>亮绿</span><br><span class="line">LIGHTCYAN<span class="number">0xFFFF55</span>亮青</span><br><span class="line">LIGHTRED<span class="number">0x5555FF</span>亮红</span><br><span class="line">LIGHTMAGENTA<span class="number">0xFF55FF</span>亮紫</span><br><span class="line">YELLOW<span class="number">0x55FFFF</span>黄</span><br><span class="line">WHITE<span class="number">0xFFFFFF</span>白</span><br></pre></td></tr></table></figure></li><li><p>自定义颜色–RGB</p><p>光学三原色：红绿蓝。调整三种颜色的比例可以合成任意颜色。RGB(红,绿,蓝)三个部分分别是0~255值。为调节到想要的颜色，可以借助电脑自带画图软件编辑颜色中找；也可以使用QQ截图，指针瞄准指定颜色后按C键复制RGB值。</p></li></ul></li><li><p>图形的输出</p><ul><li><p>例：画一个虚线为轮廓且连接处为圆形的圆（本项目按钮样式）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setlinestyle(PS_DASH | PS_ENDCAP_ROUND, 宽度像素 );</span><br><span class="line">setfillcolor(fillColor);<span class="comment">//填充色</span></span><br><span class="line">setlinecolor(lineColor);<span class="comment">//轮廓线的颜色</span></span><br><span class="line">fillcircle(x, y, radius);<span class="comment">//画圆（横坐标，纵坐标，半径）</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>文本的输出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************</span></span><br><span class="line"><span class="comment">*输入：（int类型）水印文本横坐标、（int类型）文本纵坐标、（int类型）文本字体尺寸、文本颜色</span></span><br><span class="line"><span class="comment">*输出：空</span></span><br><span class="line"><span class="comment">*作用：在任意位置生成任意大小、颜色的文本充当水印</span></span><br><span class="line"><span class="comment">************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WaterMark</span><span class="params">(<span class="keyword">int</span> textX,<span class="keyword">int</span> textY, <span class="keyword">int</span> textSize,COLORREF textColor)</span> </span>&#123;</span><br><span class="line">setbkmode(TRANSPARENT);<span class="comment">//背景透明使文本背景不再是黑色</span></span><br><span class="line">settextstyle(textSize, <span class="number">0</span>, <span class="string">&quot;隶书&quot;</span>);<span class="comment">//字体格式；</span></span><br><span class="line">settextcolor(textColor);<span class="comment">//字体颜色</span></span><br><span class="line">outtextxy(textX, textY, <span class="string">&quot;By 曹谋仁&quot;</span>);<span class="comment">//在（textX，textY）处显示“By 曹谋仁”文本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数就纯粹的体现了文本输出功能。</p><p>这里主要讲一下settextstyle函数</p><ul><li><p>设置当前字体样式–settextstyle</p><p>该函数有四个重载，这里只介绍一下本项目中使用的这一种。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">settextstyle</span><span class="params">(<span class="keyword">int</span> nHeight,<span class="keyword">int</span> nWidth,LPCTSTR lpszFace)</span></span>;</span><br></pre></td></tr></table></figure><p>nHeight–指定字符的高度（逻辑单位）。</p><p>nWidth–字符的平均宽度（逻辑单位）。如果为 0，则比例自适应。（注：上方水印文本输出函数中第二个参数为0即比例自适应后，就可以直接调节第一个参数来调节整体文本的大小。）</p><p>lpszFace–字体的种类，这里可以直接用中文加双引号来表示部分字体。</p></li></ul></li><li><p>如何更流畅地动态绘图？</p><p>在设备上不断进行绘图操作时，会产生闪频现象。为了流畅的绘图，我们可以用下面两个函数处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BeginBatchDraw();<span class="comment">//开始批量绘图</span></span><br><span class="line"><span class="comment">//这里放绘图代码</span></span><br><span class="line">EndBatchDraw();<span class="comment">//结束批量绘图</span></span><br></pre></td></tr></table></figure></li><li><p>如何进行鼠标的操作？</p><ul><li><p>存储鼠标信息的类型是ExMessage类型。故先建立记录鼠标信息的变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExMessage mouse;<span class="comment">//记录鼠标消息</span></span><br></pre></td></tr></table></figure></li><li><p>获取当前鼠标信息，并立即返回–peekmessage函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (peekmessage(&amp;mouse, EM_MOUSE)) </span><br><span class="line">&#123;<span class="comment">//如果获取到鼠标的信息，则进行这里的操作</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数也可以通过改变第二个参数来获取不同的信息：</p><table><thead><tr><th align="center">标志</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">EM_MOUSE</td><td align="center">鼠标消息。</td></tr><tr><td align="center">EM_KEY</td><td align="center">按键消息。</td></tr><tr><td align="center">EM_CHAR</td><td align="center">字符消息。</td></tr><tr><td align="center">EM_WINDOW</td><td align="center">窗口消息。</td></tr></tbody></table></li><li><p>检测鼠标上的操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (peekmessage(&amp;mouse, EM_MOUSE)) </span><br><span class="line">&#123;<span class="comment">//如果获取到鼠标的信息，则进行这里的操作</span></span><br><span class="line">    <span class="keyword">if</span> (mouse.message == WM_LBUTTONDOWN) &#123;</span><br><span class="line">        <span class="comment">//按下鼠标左键时进入这里</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，此函数不仅仅能检测到鼠标左键按下的信息，本项目关于鼠标只用到左键按下的操作，若想了解更详细→<a href="https://docs.easyx.cn/zh-cn/exmessage">EasyX 文档 - ExMessage</a></p></li></ul></li><li><p>键盘上的操作</p><p>该项目上用到的函数是：GetAsyncKeyState(键值);传入一个键值，若检测到按下则返回true。一些键值如下：</p><ul><li>上：VK_UP    下：VK_DOWN    左：VK_LEFT    右：VK_RIGHT</li><li>如果是字母按键：’字母的大写’。如果是字母小写只能检测到小写，如果是字母大写，则大小写均能检测到。</li></ul></li></ul><p>有关EasyX图形库的基本操作就介绍到这，这里主要是本项目中用到的一些功能。相比整个图形库所有功能而言实乃九牛之一毛，冰山之一角。如果想深入了解更多，请点击这里跳转→<a href="https://docs.easyx.cn/zh-cn">EasyX 文档</a></p><h2 id="菜单界面"><a href="#菜单界面" class="headerlink" title="菜单界面"></a>菜单界面</h2><p>菜单界面除了最基本的图片或文本的输出外，最主要的就是怎么实现一个按钮。</p><p>所谓的按钮就是绘制一个图形，图形中绘制一个按钮上的文本。然后在这个带有文本的图形上添加鼠标左键的监测信息。至此，一个按钮所具备的最基本的特征都已经完成了。在本项目菜单界面的按钮上，为了更好的反馈用户，增加了当鼠标指着按钮时，按钮会发生变色。源代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**************按钮信息************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUTTONNUM 3</span></span><br><span class="line"><span class="comment">//按钮顺序：&#123;开始,离开,玩法，关闭&#125;</span></span><br><span class="line"> <span class="keyword">int</span> buttonX[BUTTONNUM] = &#123; <span class="number">1042</span>,<span class="number">1335</span>,<span class="number">785</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> buttonY[BUTTONNUM] = &#123; <span class="number">563</span>,<span class="number">648</span>,<span class="number">679</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> buttonR[BUTTONNUM] = &#123; <span class="number">145</span>,<span class="number">93</span>,<span class="number">85</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> buttonTextSize[BUTTONNUM] = &#123; <span class="number">155</span>,<span class="number">70</span>,<span class="number">60</span> &#125;;</span><br><span class="line">COLORREF buttonFillColor[BUTTONNUM] = &#123; RGB(<span class="number">243</span>, <span class="number">113</span>, <span class="number">141</span>) ,RGB(<span class="number">243</span>, <span class="number">113</span>, <span class="number">141</span>) ,RGB(<span class="number">243</span>, <span class="number">113</span>, <span class="number">141</span>) &#125;;</span><br><span class="line">COLORREF buttonLineColor[BUTTONNUM] = &#123; RGB(<span class="number">255</span>, <span class="number">225</span>, <span class="number">0</span>) ,RGB(<span class="number">255</span>, <span class="number">225</span>, <span class="number">0</span>) ,RGB(<span class="number">255</span>, <span class="number">225</span>, <span class="number">0</span>) &#125;;</span><br><span class="line">COLORREF buttonTextColor[BUTTONNUM] = &#123; RGB(<span class="number">255</span>, <span class="number">225</span>, <span class="number">0</span>) ,RGB(<span class="number">255</span>, <span class="number">225</span>, <span class="number">0</span>) ,RGB(<span class="number">255</span>, <span class="number">225</span>, <span class="number">0</span>) &#125;;</span><br><span class="line"><span class="keyword">double</span> buttonLineRate[BUTTONNUM] = &#123; <span class="number">0.1</span>,<span class="number">0.1</span>,<span class="number">0.1</span>&#125;;</span><br><span class="line"><span class="comment">/***********************************/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CircleButton</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> x;<span class="comment">//圆心坐标</span></span><br><span class="line"><span class="keyword">int</span> y;</span><br><span class="line"><span class="keyword">int</span> r;<span class="comment">//半径</span></span><br><span class="line">COLORREF fillColor;</span><br><span class="line">COLORREF lineColor;</span><br><span class="line">COLORREF textColor;</span><br><span class="line"><span class="keyword">int</span> textSize;<span class="comment">//字体大小</span></span><br><span class="line"><span class="keyword">double</span> rate;<span class="comment">//轮廓线粗细占半径的比例</span></span><br><span class="line">&#125;buttons[BUTTONNUM];</span><br><span class="line"><span class="comment">/***********************</span></span><br><span class="line"><span class="comment">*输入：按钮圆心横坐标，纵坐标，半径，填充色，轮廓色，文本内容，文本大小，轮廓线粗细占半径比例</span></span><br><span class="line"><span class="comment">*输出：空</span></span><br><span class="line"><span class="comment">*作用：产生任意位置、大小、填充颜色、轮廓颜色、文本的圆形按钮</span></span><br><span class="line"><span class="comment">************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SingleButton</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y,<span class="keyword">int</span> radius , COLORREF fillColor, COLORREF lineColor, COLORREF textColor, <span class="keyword">const</span> <span class="keyword">char</span>* text,<span class="keyword">int</span> textSize,<span class="keyword">double</span> rate)</span> </span>&#123;</span><br><span class="line">setbkmode(TRANSPARENT);<span class="comment">//背景透明使文本背景不再是黑色</span></span><br><span class="line"><span class="comment">//设置画线样式为宽度是半径的0.1倍的虚线，端点为圆形</span></span><br><span class="line">setlinestyle(PS_DASH | PS_ENDCAP_ROUND, (<span class="keyword">int</span>) (rate*(<span class="keyword">double</span>)radius) );</span><br><span class="line">setfillcolor(fillColor);<span class="comment">//填充色</span></span><br><span class="line">setlinecolor(lineColor);<span class="comment">//轮廓线的颜色</span></span><br><span class="line">fillcircle(x, y, radius);<span class="comment">//画圆</span></span><br><span class="line"><span class="keyword">char</span> word[<span class="number">50</span>] = <span class="string">&quot;&quot;</span>;<span class="comment">//用于接收输入的文本</span></span><br><span class="line">strcpy_s(word, text);<span class="comment">//将输入的文本复制到Word中</span></span><br><span class="line">settextstyle(textSize, <span class="number">0</span>, <span class="string">&quot;黑体&quot;</span>);<span class="comment">//字体格式</span></span><br><span class="line"><span class="keyword">int</span> textX = x - textwidth(text) / <span class="number">2</span>;<span class="comment">//位置居中</span></span><br><span class="line"><span class="keyword">int</span> textY = y - textheight(text) / <span class="number">2</span>;</span><br><span class="line">settextcolor(textColor);<span class="comment">//字体颜色</span></span><br><span class="line">outtextxy(textX, textY, text);<span class="comment">//显示文本</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***********************</span></span><br><span class="line"><span class="comment">*输入：空</span></span><br><span class="line"><span class="comment">*输出：空</span></span><br><span class="line"><span class="comment">*作用：初始所有按钮信息</span></span><br><span class="line"><span class="comment">************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ButtonInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BUTTONNUM; i++)</span><br><span class="line">&#123;</span><br><span class="line">buttons[i].x = buttonX[i];</span><br><span class="line">buttons[i].y = buttonY[i];</span><br><span class="line">buttons[i].r = buttonR[i];</span><br><span class="line">buttons[i].textSize = buttonTextSize[i];</span><br><span class="line">buttons[i].fillColor = buttonFillColor[i];</span><br><span class="line">buttons[i].lineColor = buttonLineColor[i];</span><br><span class="line">buttons[i].textColor = buttonTextColor[i];</span><br><span class="line">buttons[i].rate = buttonLineRate[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***********************</span></span><br><span class="line"><span class="comment">*输入：空</span></span><br><span class="line"><span class="comment">*输出：空</span></span><br><span class="line"><span class="comment">*作用：绘制出菜单界面中所有按钮</span></span><br><span class="line"><span class="comment">************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawMenuButtons</span><span class="params">()</span> </span>&#123;</span><br><span class="line">SingleButton(buttons[<span class="number">0</span>].x, buttons[<span class="number">0</span>].y, buttons[<span class="number">0</span>].r, buttons[<span class="number">0</span>].fillColor, buttons[<span class="number">0</span>].lineColor,</span><br><span class="line">buttons[<span class="number">0</span>].textColor, <span class="string">&quot; GO!&quot;</span>, buttons[<span class="number">0</span>].textSize,buttons[<span class="number">0</span>].rate);<span class="comment">//绘制开始游戏按钮</span></span><br><span class="line">SingleButton(buttons[<span class="number">1</span>].x, buttons[<span class="number">1</span>].y, buttons[<span class="number">1</span>].r, buttons[<span class="number">1</span>].fillColor, buttons[<span class="number">1</span>].lineColor,</span><br><span class="line">buttons[<span class="number">1</span>].textColor, <span class="string">&quot;离开&quot;</span>, buttons[<span class="number">1</span>].textSize, buttons[<span class="number">1</span>].rate);<span class="comment">//绘制退出游戏按钮</span></span><br><span class="line">SingleButton(buttons[<span class="number">2</span>].x, buttons[<span class="number">2</span>].y, buttons[<span class="number">2</span>].r, buttons[<span class="number">1</span>].fillColor, buttons[<span class="number">2</span>].lineColor,</span><br><span class="line">buttons[<span class="number">2</span>].textColor, <span class="string">&quot;玩法&quot;</span>, buttons[<span class="number">2</span>].textSize, buttons[<span class="number">2</span>].rate);<span class="comment">//绘制玩法介绍按钮</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***********************</span></span><br><span class="line"><span class="comment">*输入：填充的新颜色，轮廓的新颜色，文本的新颜色</span></span><br><span class="line"><span class="comment">*输出：空</span></span><br><span class="line"><span class="comment">*作用：当鼠标指到菜单按钮时按钮进行变色以向用户反馈</span></span><br><span class="line"><span class="comment">************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MouseOnMenuButtons</span><span class="params">(COLORREF newFillColor, COLORREF newLineColor, COLORREF newTextColor)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">sqrt</span>(<span class="built_in">pow</span>((<span class="keyword">double</span>)mouse.x - buttons[<span class="number">0</span>].x, <span class="number">2.0</span>) + <span class="built_in">pow</span>((<span class="keyword">double</span>)mouse.y - buttons[<span class="number">0</span>].y, <span class="number">2.0</span>)) &lt;= buttons[<span class="number">0</span>].r)</span><br><span class="line">SingleButton(buttons[<span class="number">0</span>].x, buttons[<span class="number">0</span>].y, buttons[<span class="number">0</span>].r, newFillColor, newLineColor,</span><br><span class="line">newTextColor, <span class="string">&quot; GO!&quot;</span>, buttons[<span class="number">0</span>].textSize, buttons[<span class="number">0</span>].rate);<span class="comment">//鼠标指开始按钮时的变色</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">sqrt</span>(<span class="built_in">pow</span>((<span class="keyword">double</span>)mouse.x - buttons[<span class="number">1</span>].x, <span class="number">2.0</span>) + <span class="built_in">pow</span>((<span class="keyword">double</span>)mouse.y - buttons[<span class="number">1</span>].y, <span class="number">2.0</span>)) &lt;= buttons[<span class="number">1</span>].r)</span><br><span class="line">SingleButton(buttons[<span class="number">1</span>].x, buttons[<span class="number">1</span>].y, buttons[<span class="number">1</span>].r, newFillColor, newLineColor,</span><br><span class="line">newTextColor, <span class="string">&quot;离开&quot;</span>, buttons[<span class="number">1</span>].textSize, buttons[<span class="number">1</span>].rate);<span class="comment">//鼠标指离开按钮时的变色</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">sqrt</span>(<span class="built_in">pow</span>((<span class="keyword">double</span>)mouse.x - buttons[<span class="number">2</span>].x, <span class="number">2.0</span>) + <span class="built_in">pow</span>((<span class="keyword">double</span>)mouse.y - buttons[<span class="number">1</span>].y, <span class="number">2.0</span>)) &lt;= buttons[<span class="number">2</span>].r)</span><br><span class="line">SingleButton(buttons[<span class="number">2</span>].x, buttons[<span class="number">2</span>].y, buttons[<span class="number">2</span>].r, newFillColor, newLineColor,</span><br><span class="line">newTextColor, <span class="string">&quot;玩法&quot;</span>, buttons[<span class="number">2</span>].textSize, buttons[<span class="number">2</span>].rate);<span class="comment">//鼠标指玩法按钮时的变色</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">DrawMenuButtons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使文本始终在按钮中央的几何计算：</p><p><img src="https://img-blog.csdnimg.cn/2344a0d524d04943923974ca67d9e258.png"></p><p>以上是按钮的绘制，在添加鼠标左键检测时，（本项目圆形按钮）就是要保证鼠标光标的位置到圆心距离小于等于半径；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">sqrt</span>(<span class="built_in">pow</span>((<span class="keyword">double</span>)mouse.x - buttons[<span class="number">0</span>].x, <span class="number">2.0</span>) + <span class="built_in">pow</span>((<span class="keyword">double</span>)mouse.y - buttons[<span class="number">0</span>].y, <span class="number">2.0</span>)) &lt;= buttons[<span class="number">0</span>].r)</span><br><span class="line">PlayingGame();</span><br></pre></td></tr></table></figure><p>由于像素坐标是整型的，所以为保证计算更加精确，要先将坐标转换成double类型。</p><h2 id="玩法介绍界面"><a href="#玩法介绍界面" class="headerlink" title="玩法介绍界面"></a>玩法介绍界面</h2><p>这部分主要有两部分组成：现将txt中内容读取到字符串中，再将字符串放在弹窗中显示出来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************</span></span><br><span class="line"><span class="comment">*输入：空</span></span><br><span class="line"><span class="comment">*输出：空</span></span><br><span class="line"><span class="comment">*作用：从文件中读取规则，产生一个有关规则介绍的弹窗</span></span><br><span class="line"><span class="comment">************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RulesWindow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">HWND h = GetHWnd();<span class="comment">//获取窗口句柄</span></span><br><span class="line"><span class="keyword">char</span> ruleText[RULEMAX];</span><br><span class="line">FILE* fp; <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">fopen_s(&amp;fp,<span class="string">&quot;./资源/Rules.txt&quot;</span>,<span class="string">&quot;r&quot;</span>);<span class="comment">//打开存放规则文本的txt文件</span></span><br><span class="line"><span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);<span class="comment">//打不开文件时直接停止运行</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(fgets(ruleText,RULEMAX,fp)!=<span class="literal">NULL</span>)</span><br><span class="line">MessageBoxA(h, ruleText, <span class="string">&quot;玩法简介&quot;</span>, MB_OK);</span><br><span class="line">&#125; </span><br><span class="line">fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="游戏界面"><a href="#游戏界面" class="headerlink" title="游戏界面"></a>游戏界面</h2><h3 id="玩家图片的透明背景输出"><a href="#玩家图片的透明背景输出" class="headerlink" title="玩家图片的透明背景输出"></a>玩家图片的透明背景输出</h3><p>直接输出玩家飞机的图片的话，输出的样式是矩形的，影响美观。那么怎么能让计算机识别出背景并将其抠下来—-掩码图和白底原图。</p><p><img src="https://img-blog.csdnimg.cn/2ee77fa2491b49be97b74ecb21f538ab.png#pic_center"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">putimage(enemy[i].x, enemy[i].y, &amp;enemyImg[<span class="number">2</span>][<span class="number">0</span>], NOTSRCERASE);</span><br><span class="line">putimage(enemy[i].x, enemy[i].y, &amp;enemyImg[<span class="number">2</span>][<span class="number">1</span>], SRCINVERT); </span><br></pre></td></tr></table></figure><p>在同一位置先后粘贴掩码图和原图，就自然可以过滤掉背景。制作掩码图软件推荐：Photoshop。具体操作自行百度。</p><h3 id="玩家的移动"><a href="#玩家的移动" class="headerlink" title="玩家的移动"></a>玩家的移动</h3><p>当检测到相应方向按键后，玩家坐标向不同方位改变，一次改变多少像素来决定移动的速度。代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************</span></span><br><span class="line"><span class="comment">*输入：（int类型）代表玩家飞机移动的速度</span></span><br><span class="line"><span class="comment">*输出：空</span></span><br><span class="line"><span class="comment">*作用：使玩家飞机移动</span></span><br><span class="line"><span class="comment">************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyPlaneMove</span><span class="params">(<span class="keyword">int</span> speed)</span> </span>&#123;</span><br><span class="line"><span class="comment">//GetAsyncKeyState(_In_ int vKey);函数用于检测按键</span></span><br><span class="line"><span class="comment">//且移动更加流畅，可斜着移动</span></span><br><span class="line"><span class="keyword">if</span> (GetAsyncKeyState(VK_UP) || GetAsyncKeyState(<span class="string">&#x27;W&#x27;</span>)) &#123;<span class="comment">//大写W可同时表示W和w</span></span><br><span class="line"><span class="keyword">if</span>(myPlane.y&gt;<span class="number">0</span>)<span class="comment">//边界限制以防飞机移出界</span></span><br><span class="line">myPlane.y -= speed;<span class="comment">//上移</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (GetAsyncKeyState(VK_DOWN) || GetAsyncKeyState(<span class="string">&#x27;S&#x27;</span>)) &#123;</span><br><span class="line"><span class="keyword">if</span>(myPlane.y+ PLAYERHEIGHT&lt;HEIGHT)</span><br><span class="line">myPlane.y += speed;<span class="comment">//下移</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (GetAsyncKeyState(VK_LEFT) || GetAsyncKeyState(<span class="string">&#x27;A&#x27;</span>)) &#123;</span><br><span class="line"><span class="keyword">if</span>(myPlane.x+ PLAYERWIDTH /<span class="number">2</span>&gt;<span class="number">0</span>)</span><br><span class="line">myPlane.x -= speed;<span class="comment">//左移</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (GetAsyncKeyState(VK_RIGHT) || GetAsyncKeyState(<span class="string">&#x27;D&#x27;</span>)) &#123;</span><br><span class="line"><span class="keyword">if</span>(myPlane.x+ PLAYERWIDTH / <span class="number">2</span>&lt;WIDTH)</span><br><span class="line">myPlane.x += speed;<span class="comment">//右移</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//空格生成子弹</span></span><br><span class="line"><span class="comment">//引入一定延迟防止按一下空格产生多个子弹，同时可以控制相邻子弹的密度</span></span><br><span class="line"><span class="keyword">if</span> (GetAsyncKeyState(VK_SPACE) &amp;&amp; Timer(<span class="number">150</span>)) </span><br><span class="line">CreatBullet();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="敌机的产生与移动"><a href="#敌机的产生与移动" class="headerlink" title="敌机的产生与移动"></a>敌机的产生与移动</h3><p>为方便对敌机的产生或消失的控制，在其结构体中添加bool live;true产生、false消失。产生坐标在窗体顶端即y=0；横坐标在可视范围内随机生成，这里用的rand()函数。</p><p>敌机产生后自动向下移动，即纵坐标＋speed。（同玩家移动原理）。</p><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************</span></span><br><span class="line"><span class="comment">*输入：空</span></span><br><span class="line"><span class="comment">*输出：空</span></span><br><span class="line"><span class="comment">*作用：产生单个敌机</span></span><br><span class="line"><span class="comment">************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatEnemy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//敌机遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ENEMYNUM; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!enemy[i].live) &#123;<span class="comment">//遍历到一个敌机的存活状态为false，生成该单个敌机</span></span><br><span class="line"><span class="keyword">switch</span> (enemy[i].type) &#123;<span class="comment">//根据敌机类型决定血量</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>: enemy[i].hp = ENEMY0HP; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>: enemy[i].hp = ENEMY1HP; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>: enemy[i].hp = ENEMY2HP; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>: enemy[i].hp = ENEMY3HP; <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">enemy[i].live = <span class="literal">true</span>;<span class="comment">//改为存活</span></span><br><span class="line"><span class="comment">//生成飞机位置在横轴上随机（范围：[0,WIDTH - enemy[i].enemyWidth]保证显示出完整的飞机）</span></span><br><span class="line">enemy[i].x = rand() % (WIDTH - enemy[i].enemyWidth);</span><br><span class="line">enemy[i].y = <span class="number">0</span>;<span class="comment">//窗口最顶端上生成</span></span><br><span class="line"><span class="keyword">break</span>;<span class="comment">//生成单个飞机后跳出循环</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***********************</span></span><br><span class="line"><span class="comment">*输入：（int类型）表示敌机整体移动的速度（因为不同类型敌机移速不同）</span></span><br><span class="line"><span class="comment">*输出：空</span></span><br><span class="line"><span class="comment">*作用：使敌机移动</span></span><br><span class="line"><span class="comment">************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EnemyMove</span><span class="params">(<span class="keyword">int</span> speed)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ENEMYNUM; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (enemy[i].live) &#123;<span class="comment">//敌机产生后要自动向下移动</span></span><br><span class="line"><span class="comment">//两种移速方案</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 1</span></span><br><span class="line"><span class="comment">//现采取的方案：不同类型敌机用不同常数乘speed以区分出速度</span></span><br><span class="line"><span class="keyword">switch</span> (enemy[i].type)</span><br><span class="line">&#123;<span class="comment">//  0--&gt;3  快--&gt;慢  </span></span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:enemy[i].y += <span class="number">5</span> * speed; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:enemy[i].y += <span class="number">4</span> * speed; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:enemy[i].y += <span class="number">3</span> * speed; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:enemy[i].y += <span class="number">2</span> * speed; <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> 0</span></span><br><span class="line"><span class="comment">//方案二：所有敌机速度随机（由于此方案移动不太流畅，未采用）</span></span><br><span class="line">enemy[i].y += (rand() % <span class="number">10</span> + <span class="number">1</span>) * speed;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">//敌机完整地离开窗口后live恢复false以保证不断有敌机产生</span></span><br><span class="line"><span class="keyword">if</span> (enemy[i].y - enemy[i].enemyHeight &gt; HEIGHT)</span><br><span class="line">&#123;</span><br><span class="line">enemy[i].live = <span class="literal">false</span>;</span><br><span class="line">enemy[i].enemyDone = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="攻击系统"><a href="#攻击系统" class="headerlink" title="攻击系统"></a>攻击系统</h3><p>所谓攻击系统就是在飞机结构体中添加飞机的生命值，当玩家按空格绘制出一个子弹后，子弹自动向上移动，当子弹图片的区域与敌机图片区域有重叠（初中几何知识，在此不多赘述），则敌机Hp-1，子弹的live变为false即子弹打中敌机后消失。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************</span></span><br><span class="line"><span class="comment">*输入：空</span></span><br><span class="line"><span class="comment">*输出：空</span></span><br><span class="line"><span class="comment">*作用：玩家飞机攻击系统</span></span><br><span class="line"><span class="comment">************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Attack</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ENEMYNUM; i++)<span class="comment">//遍历敌机</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!enemy[i].live)</span><br><span class="line"><span class="keyword">continue</span>;<span class="comment">//跳过死亡敌机</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; BULLETNUM; j++)</span><br><span class="line">&#123;<span class="comment">//遍历子弹</span></span><br><span class="line"><span class="keyword">if</span> (!bullet[j].live)</span><br><span class="line"><span class="keyword">continue</span>;<span class="comment">//跳过死亡的子弹</span></span><br><span class="line"><span class="comment">//子弹与敌机一旦有重合区域则视为攻击有效（可用EDGE调整有效边缘）</span></span><br><span class="line"><span class="keyword">if</span> ((bullet[j].x + BULLETWIDTH &gt;= enemy[i].x -EDGE &amp;&amp; bullet[j].x &lt;= enemy[i].x + enemy[i].enemyWidth + EDGE)</span><br><span class="line">&amp;&amp; (bullet[j].y &gt;= enemy[j].y -EDGE &amp;&amp; bullet[j].y &lt;= enemy[i].y + enemy[i].enemyHeight + EDGE)) &#123;</span><br><span class="line">bullet[j].live = <span class="literal">false</span>;<span class="comment">//攻击后子弹死亡</span></span><br><span class="line">enemy[i].hp--;<span class="comment">//敌机减少一点血量</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (enemy[i].hp &lt;= <span class="number">0</span>)<span class="comment">//敌机血量&lt;=0后死亡</span></span><br><span class="line">enemy[i].live = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="玩家的血量控制"><a href="#玩家的血量控制" class="headerlink" title="玩家的血量控制"></a>玩家的血量控制</h3><p>玩家掉血的条件是：一、敌方深入我方内部； 或   二、玩家飞机与敌机直接接触。</p><p>条件一：敌机.y&gt;=窗口HEIGHT。条件二：玩家飞机图片与敌机图片有重合（同子弹与敌机的接触）。当触发扣血条件后玩家的hp-1，相应的左上角生命图片数量-1。</p><p>为避免同一敌机对玩家造成重复伤害，在结构体中加入：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> enemyDone;<span class="comment">//记录该敌机是否已经致使玩家扣血以防重复减血</span></span><br></pre></td></tr></table></figure><p>初始时，enemyDone为false，即该敌机可以对玩家造成伤害。当同一敌机首次触发扣血条件后，enemyDone变为true，此时该敌机不能再对玩家造成伤害，直到完全离开窗口然后重新初始化。</p><h3 id="游戏评分及结束界面"><a href="#游戏评分及结束界面" class="headerlink" title="游戏评分及结束界面"></a>游戏评分及结束界面</h3><p>当玩家血量减到0，游戏结束。在这里用一个弹窗中断游戏的进行，并询问是否要再来一局。如果再来一局，则用goto语句跳转到游戏的开头，如果不再继续，则用stdlib.h里的exit() 函数退出程序。</p><p>该游戏的评分就是玩家坚持的时长，坚持时间越长，即得分越高。对游戏时间的计时这里用的time.h里的clock()函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************</span></span><br><span class="line"><span class="comment">*输入：int类型  已经进行游戏的时间</span></span><br><span class="line"><span class="comment">*输出：unsigned int类型  如果游戏结束返回玩家对弹窗的选择，其他情况无意义</span></span><br><span class="line"><span class="comment">*作用：控制玩家什么时候减血或结束游戏</span></span><br><span class="line"><span class="comment">************************/</span></span><br><span class="line"><span class="function">UINT <span class="title">PlayerBlood</span><span class="params">(<span class="keyword">int</span> gameTime)</span> </span>&#123;</span><br><span class="line">HWND h = GetHWnd();<span class="comment">//获取窗口句柄</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ENEMYNUM; i++)<span class="comment">//遍历敌机</span></span><br><span class="line">&#123;  <span class="comment">//如果某敌机存活并尚未致使玩家掉血</span></span><br><span class="line"><span class="keyword">if</span> (enemy[i].live &amp;&amp; !enemy[i].enemyDone) &#123;</span><br><span class="line"><span class="comment">//减血情况一：敌机深入我方内部</span></span><br><span class="line"><span class="keyword">if</span> (enemy[i].y &gt;= HEIGHT)</span><br><span class="line">&#123;</span><br><span class="line">myPlane.hp--;</span><br><span class="line">playerBlood--;</span><br><span class="line">enemy[i].enemyDone = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//减血情况二：玩家飞机与敌机直接接触</span></span><br><span class="line"><span class="keyword">if</span> ((myPlane.x &lt; enemy[i].x + enemy[i].enemyWidth) &amp;&amp; (myPlane.x &gt; enemy[i].x - PLAYERWIDTH)</span><br><span class="line">&amp;&amp; (myPlane.y &lt; enemy[i].y + enemy[i].enemyHeight) &amp;&amp; (myPlane.y + PLAYERHEIGHT &gt; enemy[i].y))</span><br><span class="line">&#123;</span><br><span class="line">myPlane.hp--;</span><br><span class="line">playerBlood--;</span><br><span class="line">enemy[i].enemyDone = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> chTime[<span class="number">15</span>] = <span class="string">&quot;&quot;</span>;<span class="comment">//接收转换成字符串类型后的游戏时间</span></span><br><span class="line">_itoa_s(gameTime,chTime,<span class="number">15</span>,<span class="number">10</span>);<span class="comment">//_itoa_s函数将int类型转换成字符串类型</span></span><br><span class="line"><span class="comment">//拼接成一个字符串</span></span><br><span class="line"><span class="keyword">char</span> string1[<span class="number">100</span>] = <span class="string">&quot;游戏结束！太厉害了！本局中您已经坚持了&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> string2[] = <span class="string">&quot;秒！是否再来一局？&quot;</span>;</span><br><span class="line"><span class="built_in">strcat</span>(string1, chTime);</span><br><span class="line"><span class="built_in">strcat</span>(string1, string2);</span><br><span class="line"><span class="keyword">if</span> (myPlane.hp &lt;= <span class="number">0</span>)<span class="comment">//血量掉完后跳出游戏结束弹窗</span></span><br><span class="line">&#123;</span><br><span class="line">mciSendStringA(<span class="string">&quot;close ./资源/战斗BGM.mp3&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">mciSendStringA(<span class="string">&quot;open ./资源/游戏结束BGM.mp3&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">mciSendStringA(<span class="string">&quot;play ./资源/游戏结束BGM.mp3&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">UINT choice = MessageBoxA(h, string1, <span class="string">&quot;游戏结束&quot;</span>, MB_YESNO);</span><br><span class="line"><span class="keyword">return</span> choice;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//其他路径中返回一个不影响YES/NO的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="背景音乐的播放"><a href="#背景音乐的播放" class="headerlink" title="背景音乐的播放"></a>背景音乐的播放</h2><ul><li><p>库文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mmsystem.h&gt;</span><span class="comment">//多媒体播放接口头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment (lib,<span class="meta-string">&quot;winmm.lib&quot;</span>)<span class="comment">//加载静态库（用于播放音乐）</span></span></span><br></pre></td></tr></table></figure></li><li><p>打开并播放音乐。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mciSendStringA(<span class="string">&quot;open ./资源/战斗BGM.mp3&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">//打开游戏界面BGM</span></span><br><span class="line">mciSendStringA(<span class="string">&quot;play ./资源/战斗BGM.mp3 repeat&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">//播放游戏界面BGM</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/********************************************************</span></span><br><span class="line"><span class="comment"> * 程序目的：用C语言做一个飞机大战小游戏</span></span><br><span class="line"><span class="comment"> * 编译环境：visual studio 2019，EasyX_20210730</span></span><br><span class="line"><span class="comment"> * 作　　者：曹谋仁（个人Blog：https://oceanbloom.github.io/）</span></span><br><span class="line"><span class="comment"> * 发布日期：2021/9/19</span></span><br><span class="line"><span class="comment"> ********************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS<span class="comment">//防止对strcat()安全警告</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;graphics.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span> <span class="comment">//  exit() 函数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mmsystem.h&gt;</span><span class="comment">//多媒体播放接口头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment (lib,<span class="meta-string">&quot;winmm.lib&quot;</span>)<span class="comment">//加载静态库（用于播放音乐）</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYPLANEBLOOD 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STARTDELAY 2000<span class="comment">//开局敌机出没前的延迟（单位：ms）</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RULEMAX 500<span class="comment">//规则文本最大字数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BULLETNUM 100<span class="comment">//一梭子弹的数量</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ENEMYNUM 30<span class="comment">//一波敌机的数量</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EDGE 2<span class="comment">//用于调整子弹命中敌机的有效边缘范围（单位：像素）</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//四种敌机血量宏定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ENEMY0HP 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ENEMY1HP 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ENEMY2HP 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ENEMY3HP 5</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> region 图片资源尺寸</span></span><br><span class="line"><span class="comment">/************所有图片资源的尺寸************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WIDTH 1522<span class="comment">//窗口宽</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEIGHT 787<span class="comment">//窗口高</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLAYERWIDTH 97<span class="comment">//玩家飞机图片宽</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLAYERHEIGHT 75<span class="comment">//玩家飞机图片高</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLOODWIDTH 39<span class="comment">//生命值图片宽和高</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLOODHEIGHT 39</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BULLETWIDTH 30<span class="comment">//玩家子弹图片宽</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BULLETHEIGHT 60<span class="comment">//玩家子弹图片高</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EWIDTH0 59<span class="comment">//0号敌机图片宽</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EHEIGHT0 42<span class="comment">//0号敌机图片高</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EWIDTH1 80<span class="comment">//1号敌机图片宽</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EHEIGHT1 70<span class="comment">//1号敌机图片高</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EWIDTH2 99<span class="comment">//2号敌机图片宽</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EHEIGHT2 75<span class="comment">//2号敌机图片高</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EWIDTH3 125<span class="comment">//3号敌机图片宽</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EHEIGHT3 81<span class="comment">//3号敌机图片高</span></span></span><br><span class="line"><span class="comment">/****************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> endregion</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> region 按钮信息</span></span><br><span class="line"><span class="comment">/**************按钮信息************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUTTONNUM 3</span></span><br><span class="line"><span class="comment">//按钮顺序：&#123;开始,离开,玩法，关闭&#125;</span></span><br><span class="line"> <span class="keyword">int</span> buttonX[BUTTONNUM] = &#123; <span class="number">1042</span>,<span class="number">1335</span>,<span class="number">785</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> buttonY[BUTTONNUM] = &#123; <span class="number">563</span>,<span class="number">648</span>,<span class="number">679</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> buttonR[BUTTONNUM] = &#123; <span class="number">145</span>,<span class="number">93</span>,<span class="number">85</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> buttonTextSize[BUTTONNUM] = &#123; <span class="number">155</span>,<span class="number">70</span>,<span class="number">60</span> &#125;;</span><br><span class="line">COLORREF buttonFillColor[BUTTONNUM] = &#123; RGB(<span class="number">243</span>, <span class="number">113</span>, <span class="number">141</span>) ,RGB(<span class="number">243</span>, <span class="number">113</span>, <span class="number">141</span>) ,RGB(<span class="number">243</span>, <span class="number">113</span>, <span class="number">141</span>) &#125;;</span><br><span class="line">COLORREF buttonLineColor[BUTTONNUM] = &#123; RGB(<span class="number">255</span>, <span class="number">225</span>, <span class="number">0</span>) ,RGB(<span class="number">255</span>, <span class="number">225</span>, <span class="number">0</span>) ,RGB(<span class="number">255</span>, <span class="number">225</span>, <span class="number">0</span>) &#125;;</span><br><span class="line">COLORREF buttonTextColor[BUTTONNUM] = &#123; RGB(<span class="number">255</span>, <span class="number">225</span>, <span class="number">0</span>) ,RGB(<span class="number">255</span>, <span class="number">225</span>, <span class="number">0</span>) ,RGB(<span class="number">255</span>, <span class="number">225</span>, <span class="number">0</span>) &#125;;</span><br><span class="line"><span class="keyword">double</span> buttonLineRate[BUTTONNUM] = &#123; <span class="number">0.1</span>,<span class="number">0.1</span>,<span class="number">0.1</span>&#125;;</span><br><span class="line"><span class="comment">/***********************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> endregion</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Plane</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> x; <span class="comment">//横坐标</span></span><br><span class="line"><span class="keyword">int</span> y; <span class="comment">//纵坐标</span></span><br><span class="line"><span class="keyword">bool</span> live; <span class="comment">//是否存活</span></span><br><span class="line"><span class="keyword">int</span> type; <span class="comment">//飞机的类型，此处指几号敌机</span></span><br><span class="line"><span class="keyword">int</span> hp; <span class="comment">//血量，血量为0后死亡</span></span><br><span class="line"><span class="keyword">bool</span> enemyDone;<span class="comment">//记录该敌机是否已经致使玩家扣血以防重复减血</span></span><br><span class="line"><span class="keyword">int</span> enemyWidth; <span class="comment">//敌机图片宽</span></span><br><span class="line"><span class="keyword">int</span> enemyHeight; <span class="comment">//敌机图片高</span></span><br><span class="line">&#125;myPlane,bullet[BULLETNUM],enemy[ENEMYNUM];</span><br><span class="line"><span class="comment">//玩家飞机，存放子弹数据，存放敌机数据</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CircleButton</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> x;<span class="comment">//圆心坐标</span></span><br><span class="line"><span class="keyword">int</span> y;</span><br><span class="line"><span class="keyword">int</span> r;<span class="comment">//半径</span></span><br><span class="line">COLORREF fillColor;</span><br><span class="line">COLORREF lineColor;</span><br><span class="line">COLORREF textColor;</span><br><span class="line"><span class="keyword">int</span> textSize;<span class="comment">//字体大小</span></span><br><span class="line"><span class="keyword">double</span> rate;<span class="comment">//轮廓线粗细占半径的比例</span></span><br><span class="line">&#125;buttons[BUTTONNUM];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> playerBlood = MYPLANEBLOOD;<span class="comment">//玩家血量</span></span><br><span class="line">ExMessage mouse;<span class="comment">//记录鼠标消息</span></span><br><span class="line">IMAGE menuBackground;<span class="comment">//存放游戏菜单界面背景图</span></span><br><span class="line">IMAGE playingBackground;<span class="comment">//存放游戏中背景图</span></span><br><span class="line">IMAGE playerImg[<span class="number">2</span>];<span class="comment">//存放玩家飞机的图片</span></span><br><span class="line">IMAGE playerBloodImg[<span class="number">2</span>];<span class="comment">//存放玩家生命图片</span></span><br><span class="line">IMAGE bulletImg[<span class="number">2</span>];<span class="comment">//存放玩家子弹图片</span></span><br><span class="line">IMAGE enemyImg[<span class="number">4</span>][<span class="number">2</span>];<span class="comment">//存放敌机图片资源</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************</span></span><br><span class="line"><span class="comment">*输入：按钮圆心横坐标，纵坐标，半径，填充色，轮廓色，文本内容，文本大小，轮廓线粗细占半径比例</span></span><br><span class="line"><span class="comment">*输出：空</span></span><br><span class="line"><span class="comment">*作用：产生任意位置、大小、填充颜色、轮廓颜色、文本的圆形按钮</span></span><br><span class="line"><span class="comment">************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SingleButton</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y,<span class="keyword">int</span> radius , COLORREF fillColor, COLORREF lineColor, COLORREF textColor, <span class="keyword">const</span> <span class="keyword">char</span>* text,<span class="keyword">int</span> textSize,<span class="keyword">double</span> rate)</span> </span>&#123;</span><br><span class="line">setbkmode(TRANSPARENT);<span class="comment">//背景透明使文本背景不再是黑色</span></span><br><span class="line"><span class="comment">//设置画线样式为宽度是半径的0.1倍的虚线，端点为圆形</span></span><br><span class="line">setlinestyle(PS_DASH | PS_ENDCAP_ROUND, (<span class="keyword">int</span>) (rate*(<span class="keyword">double</span>)radius) );</span><br><span class="line">setfillcolor(fillColor);<span class="comment">//填充色</span></span><br><span class="line">setlinecolor(lineColor);<span class="comment">//轮廓线的颜色</span></span><br><span class="line">fillcircle(x, y, radius);<span class="comment">//画圆</span></span><br><span class="line"><span class="keyword">char</span> word[<span class="number">50</span>] = <span class="string">&quot;&quot;</span>;<span class="comment">//用于接收输入的文本</span></span><br><span class="line">strcpy_s(word, text);<span class="comment">//将输入的文本复制到Word中</span></span><br><span class="line">settextstyle(textSize, <span class="number">0</span>, <span class="string">&quot;黑体&quot;</span>);<span class="comment">//字体格式</span></span><br><span class="line"><span class="keyword">int</span> textX = x - textwidth(text) / <span class="number">2</span>;<span class="comment">//位置居中</span></span><br><span class="line"><span class="keyword">int</span> textY = y - textheight(text) / <span class="number">2</span>;</span><br><span class="line">settextcolor(textColor);<span class="comment">//字体颜色</span></span><br><span class="line">outtextxy(textX, textY, text);<span class="comment">//显示文本</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************</span></span><br><span class="line"><span class="comment">*输入：空</span></span><br><span class="line"><span class="comment">*输出：空</span></span><br><span class="line"><span class="comment">*作用：初始所有按钮信息</span></span><br><span class="line"><span class="comment">************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ButtonInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BUTTONNUM; i++)</span><br><span class="line">&#123;</span><br><span class="line">buttons[i].x = buttonX[i];</span><br><span class="line">buttons[i].y = buttonY[i];</span><br><span class="line">buttons[i].r = buttonR[i];</span><br><span class="line">buttons[i].textSize = buttonTextSize[i];</span><br><span class="line">buttons[i].fillColor = buttonFillColor[i];</span><br><span class="line">buttons[i].lineColor = buttonLineColor[i];</span><br><span class="line">buttons[i].textColor = buttonTextColor[i];</span><br><span class="line">buttons[i].rate = buttonLineRate[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************</span></span><br><span class="line"><span class="comment">*输入：空</span></span><br><span class="line"><span class="comment">*输出：空</span></span><br><span class="line"><span class="comment">*作用：绘制出菜单界面中所有按钮</span></span><br><span class="line"><span class="comment">************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawMenuButtons</span><span class="params">()</span> </span>&#123;</span><br><span class="line">SingleButton(buttons[<span class="number">0</span>].x, buttons[<span class="number">0</span>].y, buttons[<span class="number">0</span>].r, buttons[<span class="number">0</span>].fillColor, buttons[<span class="number">0</span>].lineColor,</span><br><span class="line">buttons[<span class="number">0</span>].textColor, <span class="string">&quot; GO!&quot;</span>, buttons[<span class="number">0</span>].textSize,buttons[<span class="number">0</span>].rate);<span class="comment">//绘制开始游戏按钮</span></span><br><span class="line">SingleButton(buttons[<span class="number">1</span>].x, buttons[<span class="number">1</span>].y, buttons[<span class="number">1</span>].r, buttons[<span class="number">1</span>].fillColor, buttons[<span class="number">1</span>].lineColor,</span><br><span class="line">buttons[<span class="number">1</span>].textColor, <span class="string">&quot;离开&quot;</span>, buttons[<span class="number">1</span>].textSize, buttons[<span class="number">1</span>].rate);<span class="comment">//绘制退出游戏按钮</span></span><br><span class="line">SingleButton(buttons[<span class="number">2</span>].x, buttons[<span class="number">2</span>].y, buttons[<span class="number">2</span>].r, buttons[<span class="number">1</span>].fillColor, buttons[<span class="number">2</span>].lineColor,</span><br><span class="line">buttons[<span class="number">2</span>].textColor, <span class="string">&quot;玩法&quot;</span>, buttons[<span class="number">2</span>].textSize, buttons[<span class="number">2</span>].rate);<span class="comment">//绘制玩法介绍按钮</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************</span></span><br><span class="line"><span class="comment">*输入：填充的新颜色，轮廓的新颜色，文本的新颜色</span></span><br><span class="line"><span class="comment">*输出：空</span></span><br><span class="line"><span class="comment">*作用：当鼠标指到菜单按钮时按钮进行变色以向用户反馈</span></span><br><span class="line"><span class="comment">************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MouseOnMenuButtons</span><span class="params">(COLORREF newFillColor, COLORREF newLineColor, COLORREF newTextColor)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">sqrt</span>(<span class="built_in">pow</span>((<span class="keyword">double</span>)mouse.x - buttons[<span class="number">0</span>].x, <span class="number">2.0</span>) + <span class="built_in">pow</span>((<span class="keyword">double</span>)mouse.y - buttons[<span class="number">0</span>].y, <span class="number">2.0</span>)) &lt;= buttons[<span class="number">0</span>].r)</span><br><span class="line">SingleButton(buttons[<span class="number">0</span>].x, buttons[<span class="number">0</span>].y, buttons[<span class="number">0</span>].r, newFillColor, newLineColor,</span><br><span class="line">newTextColor, <span class="string">&quot; GO!&quot;</span>, buttons[<span class="number">0</span>].textSize, buttons[<span class="number">0</span>].rate);<span class="comment">//鼠标指开始按钮时的变色</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">sqrt</span>(<span class="built_in">pow</span>((<span class="keyword">double</span>)mouse.x - buttons[<span class="number">1</span>].x, <span class="number">2.0</span>) + <span class="built_in">pow</span>((<span class="keyword">double</span>)mouse.y - buttons[<span class="number">1</span>].y, <span class="number">2.0</span>)) &lt;= buttons[<span class="number">1</span>].r)</span><br><span class="line">SingleButton(buttons[<span class="number">1</span>].x, buttons[<span class="number">1</span>].y, buttons[<span class="number">1</span>].r, newFillColor, newLineColor,</span><br><span class="line">newTextColor, <span class="string">&quot;离开&quot;</span>, buttons[<span class="number">1</span>].textSize, buttons[<span class="number">1</span>].rate);<span class="comment">//鼠标指离开按钮时的变色</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">sqrt</span>(<span class="built_in">pow</span>((<span class="keyword">double</span>)mouse.x - buttons[<span class="number">2</span>].x, <span class="number">2.0</span>) + <span class="built_in">pow</span>((<span class="keyword">double</span>)mouse.y - buttons[<span class="number">1</span>].y, <span class="number">2.0</span>)) &lt;= buttons[<span class="number">2</span>].r)</span><br><span class="line">SingleButton(buttons[<span class="number">2</span>].x, buttons[<span class="number">2</span>].y, buttons[<span class="number">2</span>].r, newFillColor, newLineColor,</span><br><span class="line">newTextColor, <span class="string">&quot;玩法&quot;</span>, buttons[<span class="number">2</span>].textSize, buttons[<span class="number">2</span>].rate);<span class="comment">//鼠标指玩法按钮时的变色</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">DrawMenuButtons();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************</span></span><br><span class="line"><span class="comment">*输入：空</span></span><br><span class="line"><span class="comment">*输出：空</span></span><br><span class="line"><span class="comment">*作用：加载图片资源</span></span><br><span class="line"><span class="comment">************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Loading</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//加载背景图</span></span><br><span class="line">loadimage(&amp;playingBackground, <span class="string">&quot;./资源/背景.png&quot;</span>);</span><br><span class="line"><span class="comment">//加载玩家掩码图+原图</span></span><br><span class="line">loadimage(&amp;playerImg[<span class="number">1</span>], <span class="string">&quot;./资源/玩家.png&quot;</span>);</span><br><span class="line">loadimage(&amp;playerImg[<span class="number">0</span>], <span class="string">&quot;./资源/玩家（掩码图）.png&quot;</span>);</span><br><span class="line"><span class="comment">//加载玩家生命图片</span></span><br><span class="line">loadimage(&amp;playerBloodImg[<span class="number">1</span>], <span class="string">&quot;./资源/生命（原图）.png&quot;</span>);</span><br><span class="line">loadimage(&amp;playerBloodImg[<span class="number">0</span>], <span class="string">&quot;./资源/生命（掩码图）.png&quot;</span>);</span><br><span class="line"><span class="comment">//加载子弹掩码图+原图</span></span><br><span class="line">loadimage(&amp;bulletImg[<span class="number">0</span>], <span class="string">&quot;./资源/子弹1（掩码图）.png&quot;</span>);</span><br><span class="line">loadimage(&amp;bulletImg[<span class="number">1</span>], <span class="string">&quot;./资源/子弹1（原图）.png&quot;</span>);</span><br><span class="line"><span class="comment">//加载敌机掩码图+原图</span></span><br><span class="line">loadimage(&amp;enemyImg[<span class="number">0</span>][<span class="number">0</span>], <span class="string">&quot;./资源/敌机0（掩码图）.png&quot;</span>);</span><br><span class="line">loadimage(&amp;enemyImg[<span class="number">0</span>][<span class="number">1</span>], <span class="string">&quot;./资源/敌机0（原图）.png&quot;</span>);</span><br><span class="line">loadimage(&amp;enemyImg[<span class="number">1</span>][<span class="number">0</span>], <span class="string">&quot;./资源/敌机1（掩码图）.png&quot;</span>);</span><br><span class="line">loadimage(&amp;enemyImg[<span class="number">1</span>][<span class="number">1</span>], <span class="string">&quot;./资源/敌机1（原图）.png&quot;</span>);</span><br><span class="line">loadimage(&amp;enemyImg[<span class="number">2</span>][<span class="number">0</span>], <span class="string">&quot;./资源/敌机2（掩码图）.png&quot;</span>);</span><br><span class="line">loadimage(&amp;enemyImg[<span class="number">2</span>][<span class="number">1</span>], <span class="string">&quot;./资源/敌机2（原图）.png&quot;</span>);</span><br><span class="line">loadimage(&amp;enemyImg[<span class="number">3</span>][<span class="number">0</span>], <span class="string">&quot;./资源/敌机3（掩码图）.png&quot;</span>);</span><br><span class="line">loadimage(&amp;enemyImg[<span class="number">3</span>][<span class="number">1</span>], <span class="string">&quot;./资源/敌机3（原图）.png&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************</span></span><br><span class="line"><span class="comment">*输入：空</span></span><br><span class="line"><span class="comment">*输出：空</span></span><br><span class="line"><span class="comment">*作用：初始化敌机数据，飞机的类型按既定比率随机生成</span></span><br><span class="line"><span class="comment">************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EnemyInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ranNum;<span class="comment">//随机数声明</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ENEMYNUM; i++)<span class="comment">//敌机遍历</span></span><br><span class="line">&#123;</span><br><span class="line">ranNum = rand() % <span class="number">10</span>;<span class="comment">//0-9随机数</span></span><br><span class="line"><span class="keyword">if</span> (ranNum &lt;= <span class="number">2</span>) &#123;<span class="comment">//随机数为0、1、2时，初始为0号敌机</span></span><br><span class="line">enemy[i].hp = ENEMY0HP;<span class="comment">//0号敌机血量</span></span><br><span class="line">enemy[i].type = <span class="number">0</span>;<span class="comment">//0号敌机</span></span><br><span class="line"><span class="comment">//0号敌机的宽和高</span></span><br><span class="line">enemy[i].enemyWidth = EWIDTH0;</span><br><span class="line">enemy[i].enemyHeight = EHEIGHT0;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ranNum &lt;= <span class="number">5</span>) &#123;<span class="comment">//随机数为3、4、5时，初始为1号敌机</span></span><br><span class="line">enemy[i].hp = ENEMY1HP;<span class="comment">//1号敌机血量</span></span><br><span class="line">enemy[i].type = <span class="number">1</span>;<span class="comment">//1号敌机</span></span><br><span class="line"><span class="comment">//1号敌机的宽和高</span></span><br><span class="line">enemy[i].enemyWidth = EWIDTH1;</span><br><span class="line">enemy[i].enemyHeight = EHEIGHT1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ranNum &lt;= <span class="number">7</span>) &#123;<span class="comment">//随机数为6、7时，初始为2号敌机</span></span><br><span class="line">enemy[i].hp = ENEMY2HP;<span class="comment">//2号敌机血量</span></span><br><span class="line">enemy[i].type = <span class="number">2</span>;<span class="comment">//2号敌机</span></span><br><span class="line"><span class="comment">//2号敌机的宽和高</span></span><br><span class="line">enemy[i].enemyWidth = EWIDTH2;</span><br><span class="line">enemy[i].enemyHeight = EHEIGHT2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ranNum &lt;= <span class="number">9</span>) &#123;<span class="comment">//随机数为8、9时，初始为3号敌机</span></span><br><span class="line">enemy[i].hp = ENEMY3HP;<span class="comment">//3号敌机血量</span></span><br><span class="line">enemy[i].type = <span class="number">3</span>;<span class="comment">//3号敌机</span></span><br><span class="line"><span class="comment">//3号敌机的宽和高</span></span><br><span class="line">enemy[i].enemyWidth = EWIDTH3;</span><br><span class="line">enemy[i].enemyHeight = EHEIGHT3;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************</span></span><br><span class="line"><span class="comment">*输入：空</span></span><br><span class="line"><span class="comment">*输出：空</span></span><br><span class="line"><span class="comment">*作用：游戏初始化函数</span></span><br><span class="line"><span class="comment">************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GameInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//玩家飞机初始位置为游戏窗口底部居中</span></span><br><span class="line">myPlane.x = (WIDTH - PLAYERWIDTH) / <span class="number">2</span>;</span><br><span class="line">myPlane.y = HEIGHT - PLAYERHEIGHT;</span><br><span class="line">myPlane.live = <span class="literal">true</span>;<span class="comment">//存活状态：true</span></span><br><span class="line">playerBlood = MYPLANEBLOOD;</span><br><span class="line">myPlane.hp = playerBlood;</span><br><span class="line"><span class="comment">//初始子弹</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BULLETNUM; i++)</span><br><span class="line">&#123;</span><br><span class="line">bullet[i].live = <span class="literal">false</span>;</span><br><span class="line">bullet[i].x = <span class="number">0</span>;</span><br><span class="line">bullet[i].y = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ENEMYNUM; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//初始状态，所有敌机均未存活。随后逐个生成</span></span><br><span class="line">enemy[i].live = <span class="literal">false</span>;</span><br><span class="line">enemy[i].enemyDone = <span class="literal">false</span>;<span class="comment">//初始时所有飞机都没有使玩家减血</span></span><br><span class="line">&#125;</span><br><span class="line">EnemyInit();<span class="comment">//初始敌机数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************</span></span><br><span class="line"><span class="comment">*输入：空</span></span><br><span class="line"><span class="comment">*输出：空</span></span><br><span class="line"><span class="comment">*作用：产生单个敌机</span></span><br><span class="line"><span class="comment">************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatEnemy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//敌机遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ENEMYNUM; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!enemy[i].live) &#123;<span class="comment">//遍历到一个敌机的存活状态为false，生成该单个敌机</span></span><br><span class="line"><span class="keyword">switch</span> (enemy[i].type) &#123;<span class="comment">//根据敌机类型决定血量</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>: enemy[i].hp = ENEMY0HP; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>: enemy[i].hp = ENEMY1HP; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>: enemy[i].hp = ENEMY2HP; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>: enemy[i].hp = ENEMY3HP; <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">enemy[i].live = <span class="literal">true</span>;<span class="comment">//改为存活</span></span><br><span class="line"><span class="comment">//生成飞机位置在横轴上随机（范围：[0,WIDTH - enemy[i].enemyWidth]保证显示出完整的飞机）</span></span><br><span class="line">enemy[i].x = rand() % (WIDTH - enemy[i].enemyWidth);</span><br><span class="line">enemy[i].y = <span class="number">0</span>;<span class="comment">//窗口最顶端上生成</span></span><br><span class="line"><span class="keyword">break</span>;<span class="comment">//生成单个飞机后跳出循环</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************</span></span><br><span class="line"><span class="comment">*输入：空</span></span><br><span class="line"><span class="comment">*输出：空</span></span><br><span class="line"><span class="comment">*作用：产生单个子弹</span></span><br><span class="line"><span class="comment">************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatBullet</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BULLETNUM; i++)<span class="comment">//遍历一梭子弹</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!bullet[i].live) &#123;<span class="comment">//遍历到一个子弹的存活状态为false，生成该单个子弹</span></span><br><span class="line">bullet[i].live = <span class="literal">true</span>;<span class="comment">//改为存活</span></span><br><span class="line"><span class="comment">//产生的位置是玩家飞机顶部中间</span></span><br><span class="line">bullet[i].x = myPlane.x + PLAYERWIDTH / <span class="number">2</span> - BULLETWIDTH / <span class="number">2</span>;</span><br><span class="line">bullet[i].y = myPlane.y - BULLETHEIGHT; </span><br><span class="line"><span class="keyword">break</span>;<span class="comment">//生成单个子弹后跳出循环</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************</span></span><br><span class="line"><span class="comment">*输入：空</span></span><br><span class="line"><span class="comment">*输出：空</span></span><br><span class="line"><span class="comment">*作用：绘制游戏图像</span></span><br><span class="line"><span class="comment">************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GameDraw</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> bloodX = <span class="number">0</span>;</span><br><span class="line">Loading();<span class="comment">//加载图片资源</span></span><br><span class="line"><span class="comment">//贴背景图</span></span><br><span class="line">putimage(<span class="number">0</span>, <span class="number">0</span>, &amp;playingBackground);</span><br><span class="line"><span class="comment">//贴生命值图片</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; playerBlood; i++)</span><br><span class="line">&#123;</span><br><span class="line">putimage(bloodX, <span class="number">0</span>, &amp;playerBloodImg[<span class="number">0</span>], NOTSRCERASE);</span><br><span class="line">putimage(bloodX, <span class="number">0</span>, &amp;playerBloodImg[<span class="number">1</span>], SRCINVERT);</span><br><span class="line">bloodX += BLOODWIDTH+<span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//贴玩家掩码图+原图</span></span><br><span class="line"><span class="keyword">if</span> (myPlane.hp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">putimage(myPlane.x, myPlane.y, &amp;playerImg[<span class="number">0</span>], NOTSRCERASE);</span><br><span class="line">putimage(myPlane.x, myPlane.y, &amp;playerImg[<span class="number">1</span>], SRCINVERT);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//贴生成子弹的图片</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BULLETNUM; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (bullet[i].live) &#123;</span><br><span class="line">putimage(bullet[i].x, bullet[i].y, &amp;bulletImg[<span class="number">0</span>], NOTSRCERASE);</span><br><span class="line">putimage(bullet[i].x, bullet[i].y, &amp;bulletImg[<span class="number">1</span>], SRCINVERT);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//贴生成敌机的图片</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ENEMYNUM; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (enemy[i].live == <span class="literal">true</span>) &#123;</span><br><span class="line"><span class="keyword">switch</span> (enemy[i].type) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">putimage(enemy[i].x, enemy[i].y, &amp;enemyImg[<span class="number">0</span>][<span class="number">0</span>], NOTSRCERASE);</span><br><span class="line">putimage(enemy[i].x, enemy[i].y, &amp;enemyImg[<span class="number">0</span>][<span class="number">1</span>], SRCINVERT); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">putimage(enemy[i].x, enemy[i].y, &amp;enemyImg[<span class="number">1</span>][<span class="number">0</span>], NOTSRCERASE);</span><br><span class="line">putimage(enemy[i].x, enemy[i].y, &amp;enemyImg[<span class="number">1</span>][<span class="number">1</span>], SRCINVERT); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">putimage(enemy[i].x, enemy[i].y, &amp;enemyImg[<span class="number">2</span>][<span class="number">0</span>], NOTSRCERASE);</span><br><span class="line">putimage(enemy[i].x, enemy[i].y, &amp;enemyImg[<span class="number">2</span>][<span class="number">1</span>], SRCINVERT); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">putimage(enemy[i].x, enemy[i].y, &amp;enemyImg[<span class="number">3</span>][<span class="number">0</span>], NOTSRCERASE);</span><br><span class="line">putimage(enemy[i].x, enemy[i].y, &amp;enemyImg[<span class="number">3</span>][<span class="number">1</span>], SRCINVERT); <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************</span></span><br><span class="line"><span class="comment">*输入：（int类型）延迟的时间，单位：ms</span></span><br><span class="line"><span class="comment">*输出：（bool类型）时间到-&gt;true; 否则-&gt;false</span></span><br><span class="line"><span class="comment">*作用：计时器</span></span><br><span class="line"><span class="comment">************************/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Timer</span><span class="params">(<span class="keyword">int</span> delay)</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> DWORD t1, t2;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">unsigned</span>(t2 - t1) &gt; <span class="keyword">unsigned</span>(delay)) &#123;</span><br><span class="line">t1 = t2;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">t2 = clock();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************</span></span><br><span class="line"><span class="comment">*输入：（int类型）代表玩家飞机移动的速度</span></span><br><span class="line"><span class="comment">*输出：空</span></span><br><span class="line"><span class="comment">*作用：使玩家飞机移动</span></span><br><span class="line"><span class="comment">************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyPlaneMove</span><span class="params">(<span class="keyword">int</span> speed)</span> </span>&#123;</span><br><span class="line"><span class="comment">//GetAsyncKeyState(_In_ int vKey);函数用于检测按键</span></span><br><span class="line"><span class="comment">//且移动更加流畅，可斜着移动</span></span><br><span class="line"><span class="keyword">if</span> (GetAsyncKeyState(VK_UP) || GetAsyncKeyState(<span class="string">&#x27;W&#x27;</span>)) &#123;<span class="comment">//大写W可同时表示W和w</span></span><br><span class="line"><span class="keyword">if</span>(myPlane.y&gt;<span class="number">0</span>)</span><br><span class="line">myPlane.y -= speed;<span class="comment">//上移</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (GetAsyncKeyState(VK_DOWN) || GetAsyncKeyState(<span class="string">&#x27;S&#x27;</span>)) &#123;</span><br><span class="line"><span class="keyword">if</span>(myPlane.y+ PLAYERHEIGHT&lt;HEIGHT)</span><br><span class="line">myPlane.y += speed;<span class="comment">//下移</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (GetAsyncKeyState(VK_LEFT) || GetAsyncKeyState(<span class="string">&#x27;A&#x27;</span>)) &#123;</span><br><span class="line"><span class="keyword">if</span>(myPlane.x+ PLAYERWIDTH /<span class="number">2</span>&gt;<span class="number">0</span>)</span><br><span class="line">myPlane.x -= speed;<span class="comment">//左移</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (GetAsyncKeyState(VK_RIGHT) || GetAsyncKeyState(<span class="string">&#x27;D&#x27;</span>)) &#123;</span><br><span class="line"><span class="keyword">if</span>(myPlane.x+ PLAYERWIDTH / <span class="number">2</span>&lt;WIDTH)</span><br><span class="line">myPlane.x += speed;<span class="comment">//右移</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//空格生成子弹</span></span><br><span class="line"><span class="comment">//引入一定延迟防止按一下空格产生多个子弹，同时可以控制相邻子弹的密度</span></span><br><span class="line"><span class="keyword">if</span> (GetAsyncKeyState(VK_SPACE) &amp;&amp; Timer(<span class="number">150</span>)) </span><br><span class="line">CreatBullet();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************</span></span><br><span class="line"><span class="comment">*输入：（int类型）代表子弹移动的速度</span></span><br><span class="line"><span class="comment">*输出：空</span></span><br><span class="line"><span class="comment">*作用：使子弹移动</span></span><br><span class="line"><span class="comment">************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BulletMove</span><span class="params">(<span class="keyword">int</span> speed)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BULLETNUM; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (bullet[i].live) &#123;<span class="comment">//存活子弹要自动向上移动</span></span><br><span class="line">bullet[i].y -= speed;<span class="comment">//上移</span></span><br><span class="line"><span class="keyword">if</span> (bullet[i].y + BULLETHEIGHT &lt; <span class="number">0</span>)<span class="comment">//子弹完全移出窗口后恢复false存活状态，以保持无限子弹</span></span><br><span class="line">bullet[i].live = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************</span></span><br><span class="line"><span class="comment">*输入：（int类型）表示敌机整体移动的速度（因为不同类型敌机移速不同）</span></span><br><span class="line"><span class="comment">*输出：空</span></span><br><span class="line"><span class="comment">*作用：使敌机移动</span></span><br><span class="line"><span class="comment">************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EnemyMove</span><span class="params">(<span class="keyword">int</span> speed)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ENEMYNUM; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (enemy[i].live) &#123;<span class="comment">//敌机产生后要自动向下移动</span></span><br><span class="line"><span class="comment">//两种移速方案</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 1</span></span><br><span class="line"><span class="comment">//现采取的方案：不同类型敌机用不同常数乘speed以区分出速度</span></span><br><span class="line"><span class="keyword">switch</span> (enemy[i].type)</span><br><span class="line">&#123;<span class="comment">//  0--&gt;3  快--&gt;慢  </span></span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:enemy[i].y += <span class="number">5</span> * speed; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:enemy[i].y += <span class="number">4</span> * speed; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:enemy[i].y += <span class="number">3</span> * speed; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:enemy[i].y += <span class="number">2</span> * speed; <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> 0</span></span><br><span class="line"><span class="comment">//方案二：所有敌机速度随机（由于此方案移动不太流畅，未采用）</span></span><br><span class="line">enemy[i].y += (rand() % <span class="number">10</span> + <span class="number">1</span>) * speed;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">//敌机完整地离开窗口后live恢复false以保证不断有敌机产生</span></span><br><span class="line"><span class="keyword">if</span> (enemy[i].y - enemy[i].enemyHeight &gt; HEIGHT)</span><br><span class="line">&#123;</span><br><span class="line">enemy[i].live = <span class="literal">false</span>;</span><br><span class="line">enemy[i].enemyDone = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************</span></span><br><span class="line"><span class="comment">*输入：空</span></span><br><span class="line"><span class="comment">*输出：空</span></span><br><span class="line"><span class="comment">*作用：玩家飞机攻击系统</span></span><br><span class="line"><span class="comment">************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Attack</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ENEMYNUM; i++)<span class="comment">//遍历敌机</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!enemy[i].live)</span><br><span class="line"><span class="keyword">continue</span>;<span class="comment">//跳过死亡敌机</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; BULLETNUM; j++)</span><br><span class="line">&#123;<span class="comment">//遍历子弹</span></span><br><span class="line"><span class="keyword">if</span> (!bullet[j].live)</span><br><span class="line"><span class="keyword">continue</span>;<span class="comment">//跳过死亡的子弹</span></span><br><span class="line"><span class="comment">//子弹与敌机一旦有重合区域则视为攻击有效（可用EDGE调整有效边缘）</span></span><br><span class="line"><span class="keyword">if</span> ((bullet[j].x + BULLETWIDTH &gt;= enemy[i].x -EDGE &amp;&amp; bullet[j].x &lt;= enemy[i].x + enemy[i].enemyWidth + EDGE)</span><br><span class="line">&amp;&amp; (bullet[j].y &gt;= enemy[j].y -EDGE &amp;&amp; bullet[j].y &lt;= enemy[i].y + enemy[i].enemyHeight + EDGE)) &#123;</span><br><span class="line">bullet[j].live = <span class="literal">false</span>;<span class="comment">//攻击后子弹死亡</span></span><br><span class="line">enemy[i].hp--;<span class="comment">//敌机减少一点血量</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (enemy[i].hp &lt;= <span class="number">0</span>)<span class="comment">//敌机血量&lt;=0后死亡</span></span><br><span class="line">enemy[i].live = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************</span></span><br><span class="line"><span class="comment">*输入：int类型  已经进行游戏的时间</span></span><br><span class="line"><span class="comment">*输出：unsigned int类型  如果游戏结束返回玩家对弹窗的选择，其他情况无意义</span></span><br><span class="line"><span class="comment">*作用：控制玩家什么时候减血或结束游戏</span></span><br><span class="line"><span class="comment">************************/</span></span><br><span class="line"><span class="function">UINT <span class="title">PlayerBlood</span><span class="params">(<span class="keyword">int</span> gameTime)</span> </span>&#123;</span><br><span class="line">HWND h = GetHWnd();<span class="comment">//获取窗口句柄</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ENEMYNUM; i++)<span class="comment">//遍历敌机</span></span><br><span class="line">&#123;  <span class="comment">//如果某敌机存活并尚未致使玩家掉血</span></span><br><span class="line"><span class="keyword">if</span> (enemy[i].live &amp;&amp; !enemy[i].enemyDone) &#123;</span><br><span class="line"><span class="comment">//减血情况一：敌机深入我方内部</span></span><br><span class="line"><span class="keyword">if</span> (enemy[i].y &gt;= HEIGHT)</span><br><span class="line">&#123;</span><br><span class="line">myPlane.hp--;</span><br><span class="line">playerBlood--;</span><br><span class="line">enemy[i].enemyDone = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//减血情况二：玩家飞机与敌机直接接触</span></span><br><span class="line"><span class="keyword">if</span> ((myPlane.x &lt; enemy[i].x + enemy[i].enemyWidth) &amp;&amp; (myPlane.x &gt; enemy[i].x - PLAYERWIDTH)</span><br><span class="line">&amp;&amp; (myPlane.y &lt; enemy[i].y + enemy[i].enemyHeight) &amp;&amp; (myPlane.y + PLAYERHEIGHT &gt; enemy[i].y))</span><br><span class="line">&#123;</span><br><span class="line">myPlane.hp--;</span><br><span class="line">playerBlood--;</span><br><span class="line">enemy[i].enemyDone = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> chTime[<span class="number">15</span>] = <span class="string">&quot;&quot;</span>;<span class="comment">//接收转换成字符串类型后的游戏时间</span></span><br><span class="line">_itoa_s(gameTime,chTime,<span class="number">15</span>,<span class="number">10</span>);<span class="comment">//_itoa_s函数将int类型转换成字符串类型</span></span><br><span class="line"><span class="comment">//拼接成一个字符串</span></span><br><span class="line"><span class="keyword">char</span> string1[<span class="number">100</span>] = <span class="string">&quot;游戏结束！太厉害了！本局中您已经坚持了&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> string2[] = <span class="string">&quot;秒！是否再来一局？&quot;</span>;</span><br><span class="line"><span class="built_in">strcat</span>(string1, chTime);</span><br><span class="line"><span class="built_in">strcat</span>(string1, string2);</span><br><span class="line"><span class="keyword">if</span> (myPlane.hp &lt;= <span class="number">0</span>)<span class="comment">//血量掉完后跳出游戏结束弹窗</span></span><br><span class="line">&#123;</span><br><span class="line">mciSendStringA(<span class="string">&quot;close ./资源/战斗BGM.mp3&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">mciSendStringA(<span class="string">&quot;open ./资源/游戏结束BGM.mp3&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">mciSendStringA(<span class="string">&quot;play ./资源/游戏结束BGM.mp3&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">UINT choice = MessageBoxA(h, string1, <span class="string">&quot;游戏结束&quot;</span>, MB_YESNO);</span><br><span class="line"><span class="keyword">return</span> choice;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//其他路径中返回一个不影响YES/NO的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************</span></span><br><span class="line"><span class="comment">*输入：int类型水印横坐标、int类型水印纵坐标、int类型水印字体尺寸、水印颜色</span></span><br><span class="line"><span class="comment">*输出：空</span></span><br><span class="line"><span class="comment">*作用：在任意位置生成任意大小、颜色的文本充当水印</span></span><br><span class="line"><span class="comment">************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WaterMark</span><span class="params">(<span class="keyword">int</span> textX,<span class="keyword">int</span> textY, <span class="keyword">int</span> textSize,COLORREF textColor)</span> </span>&#123;</span><br><span class="line">setbkmode(TRANSPARENT);<span class="comment">//背景透明使文本背景不再是黑色</span></span><br><span class="line">settextstyle(textSize, <span class="number">0</span>, <span class="string">&quot;隶书&quot;</span>);<span class="comment">//字体格式</span></span><br><span class="line">settextcolor(textColor);<span class="comment">//字体颜色</span></span><br><span class="line">outtextxy(textX, textY, <span class="string">&quot;By 曹谋仁&quot;</span>);<span class="comment">//显示文本</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************</span></span><br><span class="line"><span class="comment">*输入：空</span></span><br><span class="line"><span class="comment">*输出：空</span></span><br><span class="line"><span class="comment">*作用：游戏菜单界面</span></span><br><span class="line"><span class="comment">************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Menu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ButtonInit();</span><br><span class="line">mciSendStringA(<span class="string">&quot;open ./资源/菜单BGM.mp3&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">//打开菜单界面BGM</span></span><br><span class="line">loadimage(&amp;menuBackground, <span class="string">&quot;./资源/menuBackground.png&quot;</span>);</span><br><span class="line">putimage(<span class="number">0</span>, <span class="number">0</span>, &amp;menuBackground);</span><br><span class="line">DrawMenuButtons();</span><br><span class="line">mciSendStringA(<span class="string">&quot;play ./资源/菜单BGM.mp3 repeat&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">//播放音乐</span></span><br><span class="line">WaterMark(<span class="number">2</span>, <span class="number">763</span>, <span class="number">25</span>, RGB(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));<span class="comment">//在左下角显示水印</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************</span></span><br><span class="line"><span class="comment">*输入：空</span></span><br><span class="line"><span class="comment">*输出：空</span></span><br><span class="line"><span class="comment">*作用：玩游戏中的全过程</span></span><br><span class="line"><span class="comment">************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PlayingGame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">mciSendStringA(<span class="string">&quot;close ./资源/菜单BGM.mp3&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">//关闭菜单界面BGM</span></span><br><span class="line">mciSendStringA(<span class="string">&quot;open ./资源/战斗BGM.mp3&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">//打开游戏界面BGM</span></span><br><span class="line">L0:GameInit();<span class="comment">//初始化游戏</span></span><br><span class="line">mciSendStringA(<span class="string">&quot;play ./资源/战斗BGM.mp3 repeat&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">//播放游戏界面BGM</span></span><br><span class="line">BeginBatchDraw();<span class="comment">//开启批量绘制，使循环中图像显示流畅</span></span><br><span class="line"><span class="keyword">int</span> playTime = <span class="number">0</span>;<span class="comment">//用于记录已经进行游戏的时间，同时也是得分</span></span><br><span class="line">UINT endChoice;<span class="comment">//记录结束窗口中按钮的选择</span></span><br><span class="line">DWORD startTime=clock(), endTime=clock();</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">//经过开局延迟时间后产生敌机，产生两个敌机之间间隔0.65秒</span></span><br><span class="line"><span class="keyword">if</span> (Timer(<span class="number">650</span>) &amp;&amp; <span class="keyword">unsigned</span>(endTime - startTime) &gt; STARTDELAY) &#123;</span><br><span class="line">CreatEnemy();</span><br><span class="line">&#125;</span><br><span class="line">GameDraw();<span class="comment">//绘图</span></span><br><span class="line">FlushBatchDraw();<span class="comment">//刷新</span></span><br><span class="line">MyPlaneMove(<span class="number">22</span>);<span class="comment">//玩家飞机移动</span></span><br><span class="line">endChoice = PlayerBlood(playTime);</span><br><span class="line"><span class="keyword">if</span> (endChoice == IDYES)</span><br><span class="line">&#123;</span><br><span class="line">mciSendStringA(<span class="string">&quot;close ./资源/游戏结束BGM.mp3&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">goto</span> L0;<span class="comment">//再来一局后重新开始</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (endChoice == IDNO)</span><br><span class="line">&#123;</span><br><span class="line">mciSendStringA(<span class="string">&quot;close ./资源/战斗BGM.mp3&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">//关闭游戏界面BGM</span></span><br><span class="line">mciSendStringA(<span class="string">&quot;close ./资源/游戏结束BGM.mp3&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);<span class="comment">//结束游戏终止程序</span></span><br><span class="line">&#125;</span><br><span class="line">BulletMove(<span class="number">12</span>);<span class="comment">//子弹移动</span></span><br><span class="line">EnemyMove(<span class="number">2</span>);<span class="comment">//敌机移动</span></span><br><span class="line">Attack();<span class="comment">//攻击</span></span><br><span class="line">endTime = clock();</span><br><span class="line">playTime = ((<span class="keyword">int</span>)endTime-(<span class="keyword">int</span>)startTime) / <span class="number">1000</span>;</span><br><span class="line">&#125;</span><br><span class="line">EndBatchDraw();<span class="comment">//结束批量绘制</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************</span></span><br><span class="line"><span class="comment">*输入：空</span></span><br><span class="line"><span class="comment">*输出：空</span></span><br><span class="line"><span class="comment">*作用：从文件中读取规则，产生一个有关规则介绍的弹窗</span></span><br><span class="line"><span class="comment">************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RulesWindow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">HWND h = GetHWnd();<span class="comment">//获取窗口句柄</span></span><br><span class="line"><span class="keyword">char</span> ruleText[RULEMAX];</span><br><span class="line">FILE* fp; <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">fopen_s(&amp;fp,<span class="string">&quot;./资源/Rules.txt&quot;</span>,<span class="string">&quot;r&quot;</span>);<span class="comment">//打开存放规则文本的txt文件</span></span><br><span class="line"><span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);<span class="comment">//打不开文件时直接停止运行</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(fgets(ruleText,RULEMAX,fp)!=<span class="literal">NULL</span>)</span><br><span class="line">MessageBoxA(h, ruleText, <span class="string">&quot;玩法简介&quot;</span>, MB_OK);</span><br><span class="line">&#125; </span><br><span class="line">fclose(fp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">initgraph(WIDTH, HEIGHT);<span class="comment">//绘制窗口</span></span><br><span class="line">Menu();</span><br><span class="line">BeginBatchDraw();<span class="comment">//开启批量绘制，使循环中图像显示流畅</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">FlushBatchDraw();<span class="comment">//刷新</span></span><br><span class="line"><span class="keyword">if</span> (peekmessage(&amp;mouse, EM_MOUSE)) &#123;<span class="comment">//获取鼠标信息</span></span><br><span class="line"><span class="comment">//菜单界面中，当鼠标指针移动到按钮上时会变色以反馈用户</span></span><br><span class="line">MouseOnMenuButtons(RGB(<span class="number">56</span>, <span class="number">199</span>, <span class="number">170</span>), RGB(<span class="number">216</span>, <span class="number">120</span>, <span class="number">147</span>), RGB(<span class="number">216</span>, <span class="number">120</span>, <span class="number">147</span>));</span><br><span class="line"><span class="keyword">if</span> (mouse.message == WM_LBUTTONDOWN) &#123;<span class="comment">//按下按钮时</span></span><br><span class="line"><span class="comment">//点击&quot;Go！&quot;按钮</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">sqrt</span>(<span class="built_in">pow</span>((<span class="keyword">double</span>)mouse.x - buttons[<span class="number">0</span>].x, <span class="number">2.0</span>) + <span class="built_in">pow</span>((<span class="keyword">double</span>)mouse.y - buttons[<span class="number">0</span>].y, <span class="number">2.0</span>)) &lt;= buttons[<span class="number">0</span>].r)</span><br><span class="line">PlayingGame();</span><br><span class="line"><span class="comment">//点击&quot;离开&quot;按钮</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">sqrt</span>(<span class="built_in">pow</span>((<span class="keyword">double</span>)mouse.x - buttons[<span class="number">1</span>].x, <span class="number">2.0</span>) + <span class="built_in">pow</span>((<span class="keyword">double</span>)mouse.y - buttons[<span class="number">1</span>].y, <span class="number">2.0</span>)) &lt;= buttons[<span class="number">1</span>].r)</span><br><span class="line">&#123;</span><br><span class="line">mciSendStringA(<span class="string">&quot;close ./资源/菜单BGM.mp3&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">//关闭菜单界面BGM</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//点击&quot;玩法&quot;按钮</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">sqrt</span>(<span class="built_in">pow</span>((<span class="keyword">double</span>)mouse.x - buttons[<span class="number">2</span>].x, <span class="number">2.0</span>) + <span class="built_in">pow</span>((<span class="keyword">double</span>)mouse.y - buttons[<span class="number">2</span>].y, <span class="number">2.0</span>)) &lt;= buttons[<span class="number">2</span>].r)</span><br><span class="line">RulesWindow();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">EndBatchDraw();<span class="comment">//结束批量绘制</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="一些细节-amp-技巧"><a href="#一些细节-amp-技巧" class="headerlink" title="一些细节&amp;技巧"></a>一些细节&amp;技巧</h1><h2 id="icon图标的制作与插入"><a href="#icon图标的制作与插入" class="headerlink" title="icon图标的制作与插入"></a>icon图标的制作与插入</h2><ul><li><p>找一张或画一张图片，如果想用背景是透明的，icon支持阿尔法透明通道，所以可以用Photoshop将背景做成透明通道。随后规范其尺寸大小，常用的有12×12、16×16、24×24、32×32、48×48等。</p></li><li><p>将制作好的JPG或PNG导入转换成ico格式。我用的网站是→<a href="https://www.bitbug.net/">在线ico图标转换工具</a></p></li><li><p>在visual studio中右栏资源文件中添加制作好的ico，添加成功后编译一次exe文件的图标就会变成指定图标了。（下面图片是我链接到桌面的）</p></li></ul><p><img src="https://img-blog.csdnimg.cn/0cfacf3a50f141ebb8c59be1be69967f.png#pic_center"></p><h2 id="游戏的素材收集"><a href="#游戏的素材收集" class="headerlink" title="游戏的素材收集"></a>游戏的素材收集</h2><p>素材网站推荐→<a href="https://www.aigei.com/">爱给网</a></p><h2 id="封面的平面设计"><a href="#封面的平面设计" class="headerlink" title="封面的平面设计"></a>封面的平面设计</h2><p><img src="https://img-blog.csdnimg.cn/f2ac34ec9fbb48939ec7735736a839bf.png"></p><p>推荐网站→<a href="https://www.fotor.com.cn/">Fotor 平面设计</a></p><h1 id="易错集"><a href="#易错集" class="headerlink" title="易错集"></a>易错集</h1><ul><li><p>由于EasyX图形库只针对C++，所以源文件后缀必须是cpp，.c文件会报错。</p></li><li><p>字符集方面</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loadimage(&amp;playingBackground, <span class="string">&quot;./资源/背景.png&quot;</span>);</span><br></pre></td></tr></table></figure><p>报错：两个重载中没有一个可以转换所有参数类型。</p><p>原因：因字符集不对导致的参数有误。</p><p>解决方法：</p><ul><li>方法一：项目→属性→常规→字符集→使用多字节字符集。</li></ul></li><li><p>方法二：在字符串前面加上大写的L。</p><ul><li>方法三：用TEXT(_T())把字符串包起起来。</li></ul></li><li><p>在使用部分函数时（如：strcat()、fopen()、scanf()等函数）会有安全警告，导致无法正常运行。这是因为这些函数可能会导致数组溢出或者缓冲区溢出。</p><p>解决方法：</p><ul><li><p>方法一：在最顶端加入一行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br></pre></td></tr></table></figure><p>就是告诉Visual Studio不要在警告，并继续使用该函数。</p></li><li><p>方法二：使用微软推荐的函数：如：scanf_s()、gets_s()、fgets_s()、strcpy_s()、strcat_s() 等。这些函数均比原先的安全，但是这些函数仅限于VS，在其他编译器中无效。</p></li></ul></li></ul><h1 id="存在的缺陷"><a href="#存在的缺陷" class="headerlink" title="存在的缺陷"></a>存在的缺陷</h1><ul><li>（较严重的bug）当一直长按空格连续发射子弹时，就不会有新的敌机产生。</li><li>有关菜单中玩法介绍的弹窗中，有两个缺陷：<ul><li>从txt文件中读取规则文本时，我用的是只读取第一行，所以全部规则介绍的文本都挤在这一行，看起来很不舒服。</li><li>目前我还不会对messagebox弹窗中的文本排版，所以弹窗中文本不同规则只以几个空格分隔，没有换行，看起来很乱。（\n、<del>r</del>n都试了还是不能换行，不知道为什么。求大佬指点~）</li></ul></li><li>游戏玩法系统上比较单一，既没有关卡或BOSS，也没有技能或buff加持。</li><li>游戏进行中没有暂停功能，也没有调节背景音乐的功能。</li><li>目前游戏整体还很粗糙，还有很多细节需要去优化。比如子弹与敌机碰撞时、敌机或玩家死亡时、玩家发射子弹时看起来很生硬，都缺少音效和动画。当然，未完善更多细节也需要我学习更多新知识，以目前的水平暂时做不到的。</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.bilibili.com/video/BV1T3411r7dP">https://www.bilibili.com/video/BV1T3411r7dP</a></li><li><a href="https://docs.easyx.cn/zh-cn/intro">https://docs.easyx.cn/zh-cn/intro</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> EasyX </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
